/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

// crc32.cnx - Memory-safe CRC32 using c-next's bounded strings
// Ported from ConfigStorage.cpp with safer serialization
#include "crc32.h"
#include "AppConfig.h"

#include <stdint.h>
#include <string.h>

// ADR-044: Overflow helper functions
#include <limits.h>

static inline uint32_t cnx_clamp_add_u32(uint32_t a, uint64_t b) {
    if (b > UINT32_MAX - a) return UINT32_MAX;
    return a + (uint32_t)b;
}

/* Scope: crc32 */
uint32_t crc32_offset = 0;
uint8_t crc32_length = 0;

uint32_t crc32_calculateChecksum(const AppConfig* config) {
    crc32_offset = 0;
    char buffer[513] = "";
    crc32_length = 32 / 8;
    if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->magic, crc32_length); }
    crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
    crc32_length = 8 / 8;
    if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->version, crc32_length); }
    crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
    crc32_length = 8 / 8;
    if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->j1939SourceAddress, crc32_length); }
    crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
    for (uint32_t i = 0; i < TEMP_INPUT_COUNT; i += 1) {
        crc32_length = 16 / 8;
        if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->tempInputs[i].assignedSpn, crc32_length); }
        crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
        crc32_length = 32 / 8;
        if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->tempInputs[i].coeffA, crc32_length); }
        crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
        crc32_length = 32 / 8;
        if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->tempInputs[i].coeffB, crc32_length); }
        crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
        crc32_length = 32 / 8;
        if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->tempInputs[i].coeffC, crc32_length); }
        crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
        crc32_length = 32 / 8;
        if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->tempInputs[i].resistorValue, crc32_length); }
        crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
    }
    for (uint32_t i = 0; i < PRESSURE_INPUT_COUNT; i += 1) {
        crc32_length = 16 / 8;
        if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->pressureInputs[i].assignedSpn, crc32_length); }
        crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
        crc32_length = 16 / 8;
        if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->pressureInputs[i].maxPressure, crc32_length); }
        crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
        crc32_length = 8 / 8;
        if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->pressureInputs[i].pressureType, crc32_length); }
        crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
    }
    crc32_length = 8 / 8;
    if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->egtEnabled, crc32_length); }
    crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
    crc32_length = 8 / 8;
    if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->thermocoupleType, crc32_length); }
    crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
    crc32_length = 8 / 8;
    if (crc32_offset + crc32_length <= sizeof(buffer)) { memcpy(&buffer[crc32_offset], &config->bme280Enabled, crc32_length); }
    crc32_offset = cnx_clamp_add_u32(crc32_offset, crc32_length);
    uint32_t crc = 0xFFFFFFFF;
    for (uint32_t i = 0; i < crc32_offset; i += 1) {
        crc = crc ^ buffer[i];
        for (int32_t j = 0; j < 8; j += 1) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc = crc >> 1;
            }
        }
    }
    return ~crc;
}
