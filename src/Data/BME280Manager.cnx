// BME280 Ambient Sensor Manager
// Handles temperature, humidity, and barometric pressure readings

#include <Adafruit_BME280.h>
#include <AppConfig.cnx>
#include <Arduino.h>
#include <Wire.h>

scope BME280Manager {
    // BME280 instance (C++ object)
    Adafruit_BME280 bme;

    // Configuration
    u8 i2cAddress <- 0x76;
    bool enabled <- false;
    bool initialized <- false;

    // Latest readings
    f32 temperatureC <- 0.0;
    f32 humidity <- 0.0;
    f32 pressurekPa <- 0.0;
    bool readingValid <- false;

    // Timing for periodic reads
    u32 lastReadTime <- 0;
    const u32 READ_INTERVAL_MS <- 1000;

    // Call from main loop to update readings
    // Returns true if readings were updated
    public bool update() {
        if (!enabled || !initialized) {
            return false;
        }

        // Only read periodically to reduce I2C traffic
        u32 now <- millis();
        if (now - lastReadTime < READ_INTERVAL_MS) {
            return false;
        }

        // Read all values (BME280 reads are fast, ~1ms)
        temperatureC <- bme.readTemperature();
        humidity <- bme.readHumidity();

        // Convert from Pa to kPa
        pressurekPa <- bme.readPressure() / 1000.0;

        // Check for valid readings (NaN check)
        bool tempNan <- global.isnan(temperatureC);
        bool humNan <- global.isnan(humidity);
        bool presNan <- global.isnan(pressurekPa);
        if (tempNan || humNan || presNan) {
            readingValid <- false;
            return false;
        }

        readingValid <- true;
        lastReadTime <- now;

        return true;
    }

    // Initialize the BME280 based on config
    public void initialize(const AppConfig config) {
        enabled <- config.bme280Enabled;

        if (!enabled) {
            Serial.println("BME280 disabled in config");
            return;
        }

        // Fixed I2C address (0x76 is standard for BME280)
        i2cAddress <- 0x76;

        bool began <- bme.begin(i2cAddress);
        if (began) {
            initialized <- true;

            // Configure for weather monitoring (low power, low oversampling)
            // Using numeric values for C++ enums:
            // MODE_NORMAL=3, SAMPLING_X1=1, FILTER_OFF=0, STANDBY_MS_1000=5
            bme.setSampling(3, 1, 1, 1, 0, 5);

            Serial.print("BME280 initialized at 0x");
            Serial.println(i2cAddress, HEX);

            // Do initial read
            update();
        } else {
            initialized <- false;
            Serial.print("BME280 FAILED to initialize at 0x");
            Serial.print(i2cAddress, HEX);
            Serial.println(" - check wiring");

            // Print sensor ID for debugging
            Serial.print("  Sensor ID: 0x");
            Serial.println(bme.sensorID(), HEX);
            Serial.println("  ID 0xFF = bad address or no sensor");
            Serial.println("  ID 0x56-0x58 = BMP280");
            Serial.println("  ID 0x60 = BME280");
            Serial.println("  ID 0x61 = BME680");
        }
    }

    // Get the latest temperature reading in Celsius
    public f32 getTemperatureC() {
        if (!readingValid) {
            return -273.15;  // Return absolute zero as error indicator
        }
        return temperatureC;
    }

    // Get the latest humidity reading in %
    public f32 getHumidity() {
        if (!readingValid) {
            return 0.0;
        }
        return humidity;
    }

    // Get the latest pressure reading in kPa
    public f32 getPressurekPa() {
        if (!readingValid) {
            return 0.0;
        }
        return pressurekPa;
    }

    // Check if the device is enabled and initialized
    public bool isEnabled() {
        return enabled && initialized;
    }
}
