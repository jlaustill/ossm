/**
 * ADS1115 ADC Manager
 * Manages multiple ADS1115 devices for sensor readings
 */

#include <Arduino.h>
#include <Adafruit_ADS1X15.h>
#include "../AppConfig.cnx"
#include "types/TAdcReading.cnx"
#include <Display/HardwareMap.cnx>

scope ADS1115Manager {
    const u8 ADS_CHANNEL_COUNT <- 4;

    // Timeout for conversion (should be ~8ms at 128 SPS, use 15ms for safety)
    const u32 CONVERSION_TIMEOUT_MS <- 15;

    // ADS1115 device instances
    Adafruit_ADS1115[ADS_DEVICE_COUNT] ads;

    // Device configuration
    u8[ADS_DEVICE_COUNT] drdyPins <- [0, 0, 0, 0];
    bool[ADS_DEVICE_COUNT] deviceEnabled <- [false, false, false, false];
    bool[ADS_DEVICE_COUNT] deviceInitialized <- [false, false, false, false];

    // Reading buffers
    // Access must be protected with critical blocks for ISR safety
    TAdcReading[ADS_DEVICE_COUNT][ADS_CHANNEL_COUNT] readings;

    // State machine for round-robin cycling
    u8 currentDevice <- 0;
    u8 currentChannel <- 0;
    bool conversionStarted <- false;
    u32 conversionStartTime <- 0;

    // MUX values for single-ended channels
    const u16[4] MUX_SINGLE <- [
        ADS1X15_REG_CONFIG_MUX_SINGLE_0,
        ADS1X15_REG_CONFIG_MUX_SINGLE_1,
        ADS1X15_REG_CONFIG_MUX_SINGLE_2,
        ADS1X15_REG_CONFIG_MUX_SINGLE_3
    ];

    // Private functions

    void startConversion() {
        if (currentDevice >= ADS_DEVICE_COUNT || !deviceInitialized[currentDevice]) {
            conversionStarted <- false;
            return;
        }

        ads[currentDevice].startADCReading(MUX_SINGLE[currentChannel], false);
        conversionStarted <- true;
        conversionStartTime <- millis();
    }

    bool isConversionComplete() {
        if (!conversionStarted || currentDevice >= ADS_DEVICE_COUNT) {
            return false;
        }

        i32 pinState <- digitalRead(drdyPins[currentDevice]);
        if (pinState = LOW) {
            return true;
        }

        return ads[currentDevice].conversionComplete();
    }

    void readResult() {
        if (currentDevice >= ADS_DEVICE_COUNT || !deviceInitialized[currentDevice]) {
            return;
        }

        i16 result <- ads[currentDevice].getLastConversionResults();
        u32 now <- millis();

        critical {
            readings[currentDevice][currentChannel].rawValue <- result;
            readings[currentDevice][currentChannel].timestamp <- now;
            readings[currentDevice][currentChannel].valid <- true;
        }

        conversionStarted <- false;
    }

    void advanceChannel() {
        currentChannel <- currentChannel + 1;

        if (currentChannel >= ADS_CHANNEL_COUNT) {
            currentChannel <- 0;
            currentDevice <- currentDevice + 1;

            while (currentDevice < ADS_DEVICE_COUNT && !deviceInitialized[currentDevice]) {
                currentDevice <- currentDevice + 1;
            }

            if (currentDevice >= ADS_DEVICE_COUNT) {
                currentDevice <- 0;

                while (currentDevice < ADS_DEVICE_COUNT && !deviceInitialized[currentDevice]) {
                    currentDevice <- currentDevice + 1;
                }
            }
        }
    }

    // Public functions

    public void initialize(const AppConfig config) {
        // Initialize reading buffers
        for (u8 d <- 0; d < ADS_DEVICE_COUNT; d <- d + 1) {
            for (u8 c <- 0; c < ADS_CHANNEL_COUNT; c <- c + 1) {
                readings[d][c].rawValue <- 0;
                readings[d][c].timestamp <- 0;
                readings[d][c].valid <- false;
            }
        }

        // Determine which ADS devices need to be enabled based on input usage
        for (u8 i <- 0; i < TEMP_INPUT_COUNT; i <- i + 1) {
            if (config.tempInputs[i].assignedValue != EValueId.VALUE_UNASSIGNED) {
                u8 dev <- HardwareMap.tempDevice(i);
                deviceEnabled[dev] <- true;
            }
        }

        for (u8 i <- 0; i < PRESSURE_INPUT_COUNT; i <- i + 1) {
            if (config.pressureInputs[i].assignedValue != EValueId.VALUE_UNASSIGNED) {
                u8 dev <- HardwareMap.pressureDevice(i);
                deviceEnabled[dev] <- true;
            }
        }

        // Initialize each enabled ADS1115 device
        for (u8 d <- 0; d < ADS_DEVICE_COUNT; d <- d + 1) {
            drdyPins[d] <- ADS_DRDY_PINS[d];

            if (!deviceEnabled[d]) {
                deviceInitialized[d] <- false;
                continue;
            }

            pinMode(drdyPins[d], INPUT);

            u8 addr <- ADS_I2C_ADDRESSES[d];
            bool beginResult <- ads[d].begin(addr);
            if (beginResult) {
                deviceInitialized[d] <- true;
                // GAIN_TWOTHIRDS is default (Â±6.144V, allows 0-5V with 5V VDD)
                // RATE_ADS1115_128SPS = 0x0080
                ads[d].setDataRate(0x0080);

                Serial.print("ADS1115 @ 0x");
                Serial.print(addr, HEX);
                Serial.print(" initialized, DRDY pin D");
                Serial.println(drdyPins[d]);
            } else {
                deviceInitialized[d] <- false;
                Serial.print("ADS1115 @ 0x");
                Serial.print(addr, HEX);
                Serial.println(" FAILED to initialize");
            }
        }

        currentDevice <- 0;
        currentChannel <- 0;
        conversionStarted <- false;

        while (currentDevice < ADS_DEVICE_COUNT && !deviceInitialized[currentDevice]) {
            currentDevice <- currentDevice + 1;
        }

        if (currentDevice < ADS_DEVICE_COUNT) {
            startConversion();
        }
    }

    public bool update() {
        if (currentDevice >= ADS_DEVICE_COUNT) {
            return false;
        }

        if (!conversionStarted) {
            startConversion();
            return false;
        }

        bool conversionDone <- isConversionComplete();
        if (conversionDone) {
            readResult();
            advanceChannel();

            if (currentDevice < ADS_DEVICE_COUNT) {
                startConversion();
            }
            return true;
        }

        u32 elapsed <- millis() - conversionStartTime;
        if (elapsed > CONVERSION_TIMEOUT_MS) {
            Serial.print("ADS1115 timeout on device ");
            Serial.print(currentDevice);
            Serial.print(" channel ");
            Serial.println(currentChannel);

            readings[currentDevice][currentChannel].valid <- false;
            advanceChannel();

            if (currentDevice < ADS_DEVICE_COUNT) {
                startConversion();
            }
        }

        return false;
    }

    public TAdcReading getReading(u8 device, u8 channel) {
        TAdcReading copy <- { rawValue: 0, timestamp: 0, valid: false };

        if (device >= ADS_DEVICE_COUNT || channel >= ADS_CHANNEL_COUNT) {
            return copy;
        }

        critical {
            copy.rawValue <- readings[device][channel].rawValue;
            copy.timestamp <- readings[device][channel].timestamp;
            copy.valid <- readings[device][channel].valid;
        }

        return copy;
    }

    public f32 getVoltage(u8 device, u8 channel) {
        TAdcReading reading <- getReading(device, channel);

        if (!reading.valid) {
            return 0.0;
        }

        return ads[device].computeVolts(reading.rawValue);
    }

    public bool isDeviceEnabled(u8 device) {
        if (device >= ADS_DEVICE_COUNT) {
            return false;
        }
        return deviceEnabled[device] && deviceInitialized[device];
    }

    // Debug function to print all ADC readings
    public void printDebugInfo() {
        Serial.println("=== ADS1115 Debug ===");
        for (u8 d <- 0; d < ADS_DEVICE_COUNT; d <- d + 1) {
            Serial.print("Device ");
            Serial.print(d);
            Serial.print(" (0x");
            Serial.print(ADS_I2C_ADDRESSES[d], HEX);
            Serial.print("): enabled=");
            Serial.print(deviceEnabled[d]);
            Serial.print(" init=");
            Serial.println(deviceInitialized[d]);

            if (deviceInitialized[d]) {
                for (u8 c <- 0; c < ADS_CHANNEL_COUNT; c <- c + 1) {
                    TAdcReading reading <- readings[d][c];
                    Serial.print("  Ch");
                    Serial.print(c);
                    Serial.print(": raw=");
                    Serial.print(reading.rawValue);
                    Serial.print(" valid=");
                    Serial.print(reading.valid);
                    if (reading.valid) {
                        f32 volts <- ads[d].computeVolts(reading.rawValue);
                        Serial.print(" volts=");
                        Serial.print(volts, 3);
                    }
                    Serial.println();
                }
            }
        }
    }
}
