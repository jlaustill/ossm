/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "ADS1115Manager.h"

/**
 * ADS1115 ADC Manager
 * Manages multiple ADS1115 devices for sensor readings
 */
#include <Arduino.h>
#include <Adafruit_ADS1X15.h>
#include "../AppConfig.h"
#include "types/TAdcReading.h"
#include <Display/HardwareMap.h>

#include <stdint.h>
#include <stdbool.h>

/* Scope: ADS1115Manager */
static Adafruit_ADS1115 ADS1115Manager_ads[4] = {};
static uint8_t ADS1115Manager_drdyPins[4] = {0, 0, 0, 0};
static bool ADS1115Manager_deviceEnabled[4] = {false, false, false, false};
static bool ADS1115Manager_deviceInitialized[4] = {false, false, false, false};
static TAdcReading ADS1115Manager_readings[4][4] = {0};
static uint8_t ADS1115Manager_currentDevice = 0;
static uint8_t ADS1115Manager_currentChannel = 0;
static bool ADS1115Manager_conversionStarted = false;
static uint32_t ADS1115Manager_conversionStartTime = 0;
static const uint16_t ADS1115Manager_MUX_SINGLE[4] = {ADS1X15_REG_CONFIG_MUX_SINGLE_0, ADS1X15_REG_CONFIG_MUX_SINGLE_1, ADS1X15_REG_CONFIG_MUX_SINGLE_2, ADS1X15_REG_CONFIG_MUX_SINGLE_3};

static void ADS1115Manager_startConversion(void) {
    if (ADS1115Manager_currentDevice >= ADS_DEVICE_COUNT || !ADS1115Manager_deviceInitialized[ADS1115Manager_currentDevice]) {
        ADS1115Manager_conversionStarted = false;
        return;
    }
    ADS1115Manager_ads[ADS1115Manager_currentDevice].startADCReading(ADS1115Manager_MUX_SINGLE[ADS1115Manager_currentChannel], false);
    ADS1115Manager_conversionStarted = true;
    ADS1115Manager_conversionStartTime = millis();
}

static bool ADS1115Manager_isConversionComplete(void) {
    if (!ADS1115Manager_conversionStarted || ADS1115Manager_currentDevice >= ADS_DEVICE_COUNT) {
        return false;
    }
    int32_t pinState = digitalRead(ADS1115Manager_drdyPins[ADS1115Manager_currentDevice]);
    if (pinState == LOW) {
        return true;
    }
    return ADS1115Manager_ads[ADS1115Manager_currentDevice].conversionComplete();
}

static void ADS1115Manager_readResult(void) {
    if (ADS1115Manager_currentDevice >= ADS_DEVICE_COUNT || !ADS1115Manager_deviceInitialized[ADS1115Manager_currentDevice]) {
        return;
    }
    int16_t result = ADS1115Manager_ads[ADS1115Manager_currentDevice].getLastConversionResults();
    uint32_t now = millis();
    ADS1115Manager_readings[ADS1115Manager_currentDevice][ADS1115Manager_currentChannel].rawValue = result;
    ADS1115Manager_readings[ADS1115Manager_currentDevice][ADS1115Manager_currentChannel].timestamp = now;
    ADS1115Manager_readings[ADS1115Manager_currentDevice][ADS1115Manager_currentChannel].valid = true;
    ADS1115Manager_conversionStarted = false;
}

static void ADS1115Manager_advanceChannel(void) {
    ADS1115Manager_currentChannel = ADS1115Manager_currentChannel + 1;
    if (ADS1115Manager_currentChannel >= 4) {
        ADS1115Manager_currentChannel = 0;
        ADS1115Manager_currentDevice = ADS1115Manager_currentDevice + 1;
        while (ADS1115Manager_currentDevice < ADS_DEVICE_COUNT && !ADS1115Manager_deviceInitialized[ADS1115Manager_currentDevice]) {
            ADS1115Manager_currentDevice = ADS1115Manager_currentDevice + 1;
        }
        if (ADS1115Manager_currentDevice >= ADS_DEVICE_COUNT) {
            ADS1115Manager_currentDevice = 0;
            while (ADS1115Manager_currentDevice < ADS_DEVICE_COUNT && !ADS1115Manager_deviceInitialized[ADS1115Manager_currentDevice]) {
                ADS1115Manager_currentDevice = ADS1115Manager_currentDevice + 1;
            }
        }
    }
}

void ADS1115Manager_initialize(const AppConfig& config) {
    for (uint8_t d = 0; d < ADS_DEVICE_COUNT; d = d + 1) {
        for (uint8_t c = 0; c < 4; c = c + 1) {
            ADS1115Manager_readings[d][c].rawValue = 0;
            ADS1115Manager_readings[d][c].timestamp = 0;
            ADS1115Manager_readings[d][c].valid = false;
        }
    }
    for (uint8_t i = 0; i < TEMP_INPUT_COUNT; i = i + 1) {
        if (config.tempInputs[i].assignedSpn != 0) {
            uint8_t dev = HardwareMap_tempDevice(i);
            ADS1115Manager_deviceEnabled[dev] = true;
        }
    }
    for (uint8_t i = 0; i < PRESSURE_INPUT_COUNT; i = i + 1) {
        if (config.pressureInputs[i].assignedSpn != 0) {
            uint8_t dev = HardwareMap_pressureDevice(i);
            ADS1115Manager_deviceEnabled[dev] = true;
        }
    }
    for (uint8_t d = 0; d < ADS_DEVICE_COUNT; d = d + 1) {
        ADS1115Manager_drdyPins[d] = ADS_DRDY_PINS[d];
        if (!ADS1115Manager_deviceEnabled[d]) {
            ADS1115Manager_deviceInitialized[d] = false;
            continue;
        }
        pinMode(ADS1115Manager_drdyPins[d], INPUT);
        uint8_t addr = ADS_I2C_ADDRESSES[d];
        bool beginResult = ADS1115Manager_ads[d].begin(addr);
        if (beginResult) {
            ADS1115Manager_deviceInitialized[d] = true;
            ADS1115Manager_ads[d].setGain(1);
            ADS1115Manager_ads[d].setDataRate(0x0080);
            Serial.print("ADS1115 @ 0x");
            Serial.print(addr, HEX);
            Serial.print(" initialized, DRDY pin D");
            Serial.println(ADS1115Manager_drdyPins[d]);
        } else {
            ADS1115Manager_deviceInitialized[d] = false;
            Serial.print("ADS1115 @ 0x");
            Serial.print(addr, HEX);
            Serial.println(" FAILED to initialize");
        }
    }
    ADS1115Manager_currentDevice = 0;
    ADS1115Manager_currentChannel = 0;
    ADS1115Manager_conversionStarted = false;
    while (ADS1115Manager_currentDevice < ADS_DEVICE_COUNT && !ADS1115Manager_deviceInitialized[ADS1115Manager_currentDevice]) {
        ADS1115Manager_currentDevice = ADS1115Manager_currentDevice + 1;
    }
    if (ADS1115Manager_currentDevice < ADS_DEVICE_COUNT) {
        ADS1115Manager_startConversion();
    }
}

bool ADS1115Manager_update(void) {
    if (ADS1115Manager_currentDevice >= ADS_DEVICE_COUNT) {
        return false;
    }
    if (!ADS1115Manager_conversionStarted) {
        ADS1115Manager_startConversion();
        return false;
    }
    bool conversionDone = ADS1115Manager_isConversionComplete();
    if (conversionDone) {
        ADS1115Manager_readResult();
        ADS1115Manager_advanceChannel();
        if (ADS1115Manager_currentDevice < ADS_DEVICE_COUNT) {
            ADS1115Manager_startConversion();
        }
        return true;
    }
    uint32_t elapsed = millis() - ADS1115Manager_conversionStartTime;
    if (elapsed > 15) {
        Serial.print("ADS1115 timeout on device ");
        Serial.print(ADS1115Manager_currentDevice);
        Serial.print(" channel ");
        Serial.println(ADS1115Manager_currentChannel);
        ADS1115Manager_readings[ADS1115Manager_currentDevice][ADS1115Manager_currentChannel].valid = false;
        ADS1115Manager_advanceChannel();
        if (ADS1115Manager_currentDevice < ADS_DEVICE_COUNT) {
            ADS1115Manager_startConversion();
        }
    }
    return false;
}

TAdcReading ADS1115Manager_getReading(uint8_t device, uint8_t channel) {
    TAdcReading copy = (TAdcReading){ .rawValue = 0, .timestamp = 0, .valid = false };
    if (device >= ADS_DEVICE_COUNT || channel >= 4) {
        return copy;
    }
    copy.rawValue = ADS1115Manager_readings[device][channel].rawValue;
    copy.timestamp = ADS1115Manager_readings[device][channel].timestamp;
    copy.valid = ADS1115Manager_readings[device][channel].valid;
    return copy;
}

float ADS1115Manager_getVoltage(uint8_t device, uint8_t channel) {
    TAdcReading reading = ADS1115Manager_getReading(device, channel);
    if (!reading.valid) {
        return 0.0;
    }
    return ADS1115Manager_ads[device].computeVolts(reading.rawValue);
}

bool ADS1115Manager_isDeviceEnabled(uint8_t device) {
    if (device >= ADS_DEVICE_COUNT) {
        return false;
    }
    return ADS1115Manager_deviceEnabled[device] && ADS1115Manager_deviceInitialized[device];
}
