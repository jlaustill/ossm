// config_storage.cnx - EEPROM configuration persistence
// Manages loading, saving, and validating AppConfig in EEPROM
#include <Arduino.h>
#include <AppConfig.cnx>
#include <EEPROM.h>
#include <Display/Crc32.cnx>

scope ConfigStorage {
    // EEPROM storage address for configuration
    const i32 EEPROM_CONFIG_ADDRESS <- 0;

    // Validate configuration structure
    public bool validateConfig(const AppConfig config) {
        // Check magic number
        if (config.magic != CONFIG_MAGIC) {
            return false;
        }

        // Check version
        if (config.version != CONFIG_VERSION) {
            return false;
        }

        // Verify checksum
        u32 calculatedChecksum <- global.Crc32.calculateChecksum(config);
        if (calculatedChecksum != config.checksum) {
            return false;
        }

        return true;
    }

    // Load default configuration values
    public void loadDefaults(AppConfig config) {
        // Clear structure - fields will be set explicitly below
        // (C-Next transpiler handles struct initialization)

        // Header
        config.magic <- CONFIG_MAGIC;
        config.version <- CONFIG_VERSION;
        config.j1939SourceAddress <- 149;

        // All temperature inputs disabled by default
        // Pre-load with AEM NTC coefficients so they're ready when enabled
        for (u32 i <- 0; i < TEMP_INPUT_COUNT; i +<- 1) {
            config.tempInputs[i].assignedValue <- global.EValueId.VALUE_UNASSIGNED;
            config.tempInputs[i].coeffA <- AEM_TEMP_COEFF_A;
            config.tempInputs[i].coeffB <- AEM_TEMP_COEFF_B;
            config.tempInputs[i].coeffC <- AEM_TEMP_COEFF_C;
            config.tempInputs[i].resistorValue <- AEM_TEMP_RESISTOR;
        }

        // All pressure inputs disabled by default
        // Pre-load with 100 PSIG range (gauge pressure)
        for (u32 i <- 0; i < PRESSURE_INPUT_COUNT; i +<- 1) {
            config.pressureInputs[i].assignedValue <- global.EValueId.VALUE_UNASSIGNED;
            config.pressureInputs[i].maxPressure <- 100;
            config.pressureInputs[i].pressureType <- global.EPressureType.PRESSURE_TYPE_PSIG;
            config.pressureInputs[i].reserved <- 0;
        }

        // EGT disabled by default
        config.egtEnabled <- false;
        config.thermocoupleType <- global.EThermocoupleType.TC_TYPE_K;

        // BME280 disabled by default
        config.bme280Enabled <- false;

        // Calculate and set checksum
        config.checksum <- global.Crc32.calculateChecksum(config);
    }

    // Save configuration to EEPROM
    // Returns true on success
    public bool saveConfig(const AppConfig config) {
        // Create a copy with updated checksum
        AppConfig configToSave <- config;
        configToSave.checksum <- global.Crc32.calculateChecksum(config);

        global.EEPROM.put(this.EEPROM_CONFIG_ADDRESS, configToSave);
        return true;
    }

    // Load configuration from EEPROM into provided struct
    // If EEPROM data is invalid, loads defaults and saves them
    public void loadConfig(AppConfig config) {
        global.EEPROM.get(this.EEPROM_CONFIG_ADDRESS, config);

        bool isValid <- this.validateConfig(config);
        if (!isValid) {
            Serial.println("Loading default configuration");
            this.loadDefaults(config);
            this.saveConfig(config);
        } else {
            Serial.println("Configuration loaded from EEPROM");
        }
    }
}
