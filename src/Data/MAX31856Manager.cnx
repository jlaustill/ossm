// MAX31856 Thermocouple Manager
// Handles EGT (Exhaust Gas Temperature) readings via SPI

#include <Adafruit_MAX31856.h>
#include "AppConfig.h"
#include <Arduino.h>
#include <SPI.h>

// Pin configuration - must be const for C++ constructor
const u8 thermoCoupleCs <- 10;

// MAX31856 instance with CS pin (file-level for constructor syntax)
Adafruit_MAX31856 thermocouple(thermoCoupleCs);

scope MAX31856Manager {
    // Pin configuration
    const u8 drdyPin <- 2;
    const u8 faultPin <- 3;

    // Conversion timing
    const u32 CONVERSION_TIMEOUT_MS <- 500;

    // State
    bool enabled <- false;
    bool initialized <- false;
    bool conversionStarted <- false;
    u32 conversionStartTime <- 0;

    // Latest readings
    f32 temperatureC <- 0.0;
    f32 coldJunctionC <- 0.0;
    u8 faultCode <- 0;
    bool readingValid <- false;

    // Start a one-shot conversion
    void startConversion() {
        if (!enabled || !initialized) {
            conversionStarted <- false;
            return;
        }

        thermocouple.triggerOneShot();
        conversionStarted <- true;
        conversionStartTime <- millis();
    }

    // Check if conversion is complete
    bool isConversionComplete() {
        if (!conversionStarted || !enabled || !initialized) {
            return false;
        }

        // Check DRDY pin (active low when data ready)
        i32 drdyState <- digitalRead(drdyPin);
        if (drdyState = LOW) {
            return true;
        }

        // Fallback: poll the conversion complete status
        return thermocouple.conversionComplete();
    }

    // Read the conversion result
    void readResult() {
        if (!enabled || !initialized) {
            return;
        }

        // Check for faults first
        faultCode <- thermocouple.readFault();

        if (faultCode != 0) {
            // Fault detected - reading invalid
            readingValid <- false;
        } else {
            // Read temperatures
            temperatureC <- thermocouple.readThermocoupleTemperature();
            coldJunctionC <- thermocouple.readCJTemperature();
            readingValid <- true;
        }

        conversionStarted <- false;
    }

    // Initialize the MAX31856 based on config
    public void initialize(const AppConfig config) {
        enabled <- config.egtEnabled;

        if (!enabled) {
            Serial.println("MAX31856 disabled in config");
            return;
        }

        // Configure pins
        pinMode(drdyPin, INPUT);
        pinMode(faultPin, INPUT);

        bool began <- thermocouple.begin();
        if (began) {
            initialized <- true;

            // Configure thermocouple type from config
            // Cast enum to u8 for C++ library compatibility
            thermocouple.setThermocoupleType((u8)config.thermocoupleType);

            // Set noise rejection (60Hz for North America)
            // MAX31856_NOISE_FILTER_60HZ = 0
            thermocouple.setNoiseFilter(0);

            // Use one-shot mode for lower power
            // MAX31856_ONESHOT = 0
            thermocouple.setConversionMode(0);

            Serial.println("MAX31856 initialized");

            // Start first conversion
            startConversion();
        } else {
            initialized <- false;
            Serial.println("MAX31856 FAILED to initialize");
        }
    }

    // Call from main loop to update readings
    // Returns true if a new reading is available
    public bool update() {
        if (!enabled || !initialized) {
            return false;
        }

        // No conversion in progress, start one
        if (!conversionStarted) {
            startConversion();
            return false;
        }

        // Check if conversion is complete
        bool complete <- isConversionComplete();
        if (complete) {
            readResult();

            // Start next conversion immediately
            startConversion();
            return true;
        }

        // Check for timeout
        u32 now <- millis();
        if (now - conversionStartTime > CONVERSION_TIMEOUT_MS) {
            // Timeout - reading invalid, will retry
            readingValid <- false;
            conversionStarted <- false;

            // Try to start a new conversion
            startConversion();
        }

        return false;
    }

    // Get the latest temperature reading in Celsius
    public f32 getTemperatureC() {
        if (!readingValid) {
            return -273.15;  // Return absolute zero as error indicator
        }
        return temperatureC;
    }

    // Get the latest cold junction temperature in Celsius
    public f32 getColdJunctionC() {
        if (!readingValid) {
            return -273.15;
        }
        return coldJunctionC;
    }

    // Check if the device is enabled and initialized
    public bool isEnabled() {
        return enabled && initialized;
    }

    // Get the fault status code
    public u8 getFaultStatus() {
        return faultCode;
    }
}
