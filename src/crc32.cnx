// crc32.cnx - Memory-safe CRC32 using c-next's bounded strings
// Ported from ConfigStorage.cpp with safer serialization

#include "AppConfig.h"

scope crc32 {
    u32 offset <- 0;
    u8 length <- 0;

// Calculate CRC32 checksum over AppConfig struct (excluding checksum field)
// Uses explicit field serialization instead of raw memory access
public u32 calculateChecksum(const AppConfig config) {
    // Reset offset for each call (scope variables are static)
    this.offset <- 0;

    // Bounded string for serialization (AppConfig is ~200 bytes)
    string<512> buffer <- "";

    // Serialize header fields
    this.length <- config.magic.length / 8;
    buffer[this.offset, this.length] <- config.magic;
    this.offset +<- this.length;

    this.length <- config.version.length / 8;
    buffer[this.offset, this.length] <- config.version;
    this.offset +<- this.length;

    this.length <- config.j1939SourceAddress.length / 8;
    buffer[this.offset, this.length] <- config.j1939SourceAddress;
    this.offset +<- this.length;

    // Skip reserved padding (2 bytes) - don't serialize undefined values

    // Serialize temperature inputs (8 structs)
    for (u32 i <- 0; i < TEMP_INPUT_COUNT; i +<- 1) {
        this.length <- config.tempInputs[i].assignedSpn.length / 8;
        buffer[this.offset, this.length] <- config.tempInputs[i].assignedSpn;
        this.offset +<- this.length;

        // Float fields (4 bytes each)
        this.length <- config.tempInputs[i].coeffA.length / 8;
        buffer[this.offset, this.length] <- config.tempInputs[i].coeffA;
        this.offset +<- this.length;

        this.length <- config.tempInputs[i].coeffB.length / 8;
        buffer[this.offset, this.length] <- config.tempInputs[i].coeffB;
        this.offset +<- this.length;

        this.length <- config.tempInputs[i].coeffC.length / 8;
        buffer[this.offset, this.length] <- config.tempInputs[i].coeffC;
        this.offset +<- this.length;

        this.length <- config.tempInputs[i].resistorValue.length / 8;
        buffer[this.offset, this.length] <- config.tempInputs[i].resistorValue;
        this.offset +<- this.length;
    }

    // Serialize pressure inputs (7 structs)
    for (u32 i <- 0; i < PRESSURE_INPUT_COUNT; i +<- 1) {
        this.length <- config.pressureInputs[i].assignedSpn.length / 8;
        buffer[this.offset, this.length] <- config.pressureInputs[i].assignedSpn;
        this.offset +<- this.length;

        this.length <- config.pressureInputs[i].maxPressure.length / 8;
        buffer[this.offset, this.length] <- config.pressureInputs[i].maxPressure;
        this.offset +<- this.length;

        this.length <- config.pressureInputs[i].pressureType.length / 8;
        buffer[this.offset, this.length] <- config.pressureInputs[i].pressureType;
        this.offset +<- this.length;

        // Skip reserved byte (1 byte padding)
    }

    // Serialize thermocouple config
    this.length <- config.egtEnabled.length / 8;
    buffer[this.offset, this.length] <- config.egtEnabled;
    this.offset +<- this.length;

    this.length <- config.thermocoupleType.length / 8;
    buffer[this.offset, this.length] <- config.thermocoupleType;
    this.offset +<- this.length;

    // Skip tcReserved (2 bytes padding)

    // Serialize BME280 config
    this.length <- config.bme280Enabled.length / 8;
    buffer[this.offset, this.length] <- config.bme280Enabled;
    this.offset +<- this.length;

    // Skip bme280Reserved (3 bytes padding)

    // NOTE: We intentionally DON'T serialize config.checksum - that's the field we're calculating!

    // Calculate CRC32 over serialized bytes
    u32 crc <- 0xFFFFFFFF;

    for (u32 i <- 0; i < this.offset; i +<- 1) {
        crc <- crc ^ buffer[i];

        for (i32 j <- 0; j < 8; j +<- 1) {
            if (crc & 1) {
                crc <- (crc >> 1) ^ 0xEDB88320;
            } else {
                crc <- crc >> 1;
            }
        }
    }

    return ~crc;
}
}