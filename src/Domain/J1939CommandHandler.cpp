/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "J1939CommandHandler.h"

/**
 * J1939 Command Handler
 * Thin transport: poll CAN buffer -> u8[8] -> CommandHandler.process()
 * Sends responses on PGN 65281 via J1939Bus.sendMessage()
 */
#include <AppConfig.h>
#include <Display/J1939Bus.h>
#include <Domain/CommandHandler.h>
#include <Display/FloatBytes.h>

#include <stdint.h>
#include <stdbool.h>

// ADR-044: Debug overflow helper functions (panic on overflow)
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

static inline uint8_t cnx_clamp_add_u8(uint8_t a, uint32_t b) {
    if (b > (uint32_t)(UINT8_MAX - a)) {
        fprintf(stderr, "PANIC: Integer overflow in u8 addition\n");
        abort();
    }
    uint8_t result;
    if (__builtin_add_overflow(a, (uint8_t)b, &result)) {
        fprintf(stderr, "PANIC: Integer overflow in u8 addition\n");
        abort();
    }
    return result;
}

/* Scope: J1939CommandHandler */
static elapsedMillis J1939CommandHandler_halfSecondMillis = {};
static elapsedMillis J1939CommandHandler_oneSecondMillis = {};

static void J1939CommandHandler_sendScheduledPgns(void) {
    if (J1939CommandHandler_halfSecondMillis >= 500) {
        J1939Bus_sendPgnGeneric(65270);
        J1939Bus_sendPgnGeneric(65263);
        J1939Bus_sendPgnGeneric(65190);
        J1939CommandHandler_halfSecondMillis = 0;
    }
    if (J1939CommandHandler_oneSecondMillis >= 1000) {
        J1939Bus_sendPgnGeneric(65269);
        J1939Bus_sendPgnGeneric(65262);
        J1939Bus_sendPgnGeneric(65129);
        J1939Bus_sendPgnGeneric(65189);
        J1939Bus_sendPgnGeneric(65164);
        J1939CommandHandler_oneSecondMillis = 0;
    }
}

static void J1939CommandHandler_fillBuffer(uint8_t buf[8]) {
    for (uint8_t i = 0; i < 8; i += 1) {
        buf[i] = 0xFF;
    }
}

static void J1939CommandHandler_sendConfigResponse(uint8_t cmd, uint8_t resultCode, const uint8_t data[8], uint8_t dataLen) {
    uint8_t buf[8] = {0};
    buf[0] = cmd;
    buf[1] = resultCode;
    for (uint8_t i = 0; i < 6; i += 1) {
        if (i < dataLen) {
            buf[2 + i] = data[i];
        } else {
            buf[2 + i] = 0xFF;
        }
    }
    J1939Bus_sendMessage(65281, buf);
}

static void J1939CommandHandler_handleQuery(const uint8_t data[8]) {
    uint8_t queryType = data[1];
    uint8_t subQuery = data[2];
    uint8_t respData[8] = {0};
    J1939CommandHandler_fillBuffer(respData);
    switch (queryType) {
        case 0: {
            uint8_t tempCount = 0;
            uint8_t presCount = 0;
            for (uint8_t i = 0; i < TEMP_INPUT_COUNT; i += 1) {
                if (appConfig.tempInputs[i].assignedValue != EValueId_VALUE_UNASSIGNED) {
                    tempCount = cnx_clamp_add_u8(tempCount, 1);
                }
            }
            for (uint8_t i = 0; i < PRESSURE_INPUT_COUNT; i += 1) {
                if (appConfig.pressureInputs[i].assignedValue != EValueId_VALUE_UNASSIGNED) {
                    presCount = cnx_clamp_add_u8(presCount, 1);
                }
            }
            respData[0] = tempCount;
            respData[1] = presCount;
            if (appConfig.egtEnabled) {
                respData[2] = 1;
            } else {
                respData[2] = 0;
            }
            if (appConfig.bme280Enabled) {
                respData[3] = 1;
            } else {
                respData[3] = 0;
            }
            J1939CommandHandler_sendConfigResponse(5, static_cast<uint8_t>(ECommandResult_CMD_SUCCESS), respData, 4);
            break;
        }
        case 1: {
            uint8_t startIdx = subQuery * 6;
            for (uint8_t i = 0; i < 6; i += 1) {
                uint8_t idx = startIdx + i;
                if (idx < TEMP_INPUT_COUNT) {
                    respData[i] = static_cast<uint8_t>(appConfig.tempInputs[idx].assignedValue);
                } else {
                    respData[i] = static_cast<uint8_t>(EValueId_VALUE_UNASSIGNED);
                }
            }
            J1939CommandHandler_sendConfigResponse(5, static_cast<uint8_t>(ECommandResult_CMD_SUCCESS), respData, 6);
            break;
        }
        case 2: {
            uint8_t startIdx = subQuery * 6;
            for (uint8_t i = 0; i < 6; i += 1) {
                uint8_t idx = startIdx + i;
                if (idx < PRESSURE_INPUT_COUNT) {
                    respData[i] = static_cast<uint8_t>(appConfig.pressureInputs[idx].assignedValue);
                } else {
                    respData[i] = static_cast<uint8_t>(EValueId_VALUE_UNASSIGNED);
                }
            }
            J1939CommandHandler_sendConfigResponse(5, static_cast<uint8_t>(ECommandResult_CMD_SUCCESS), respData, 6);
            break;
        }
        case 4: {
            respData[0] = appConfig.j1939SourceAddress;
            respData[1] = static_cast<uint8_t>(appConfig.thermocoupleType);
            J1939CommandHandler_sendConfigResponse(5, static_cast<uint8_t>(ECommandResult_CMD_SUCCESS), respData, 2);
            break;
        }
        default: {
            J1939CommandHandler_sendConfigResponse(5, static_cast<uint8_t>(ECommandResult_CMD_UNKNOWN_COMMAND), respData, 0);
            break;
        }
    }
}

static void J1939CommandHandler_handleNtcParam(const uint8_t data[8]) {
    uint8_t input = data[1];
    uint8_t param = data[2];
    float value = FloatBytes_fromBytesLE(data[3], data[4], data[5], data[6]);
    ECommandResult result = CommandHandler_setNtcParam(input, param, value);
    uint8_t emptyData[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    J1939CommandHandler_sendConfigResponse(10, static_cast<uint8_t>(result), emptyData, 0);
}

static void J1939CommandHandler_processCommand(const uint8_t data[8]) {
    uint8_t cmd = data[0];
    switch (cmd) {
        case 5: {
            J1939CommandHandler_handleQuery(data);
            return;
            break;
        }
        case 10: {
            J1939CommandHandler_handleNtcParam(data);
            return;
            break;
        }
    }
    ECommandResult result = CommandHandler_process(data);
    uint8_t emptyData[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    J1939CommandHandler_sendConfigResponse(cmd, static_cast<uint8_t>(result), emptyData, 0);
}

void J1939CommandHandler_update(void) {
    J1939CommandHandler_sendScheduledPgns();
    bool pending = J1939Bus_hasPendingCommand();
    if (!pending) {
        return;
    }
    uint8_t data[8] = {0};
    J1939Bus_getPendingCommand(data);
    J1939CommandHandler_processCommand(data);
}
