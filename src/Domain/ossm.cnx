// Main OSSM application logic
// Handles sensor polling, J1939 messaging, and command processing

#include <Arduino.h>
#include <AppConfig.cnx>

#include "../Data/ConfigStorage.cnx"
#include "../Data/ADS1115Manager.cnx"
#include "../Data/MAX31856Manager.cnx"
#include "../Data/BME280Manager.cnx"
#include "SensorProcessor.cnx"
#include "CommandHandler.cnx"
#include <Data/SensorValues.cnx>
#include <Display/J1939Bus.cnx>
#include "SerialCommandHandler.cnx"

scope Ossm {
    // Static member variables
    IntervalTimer sensorTimer;
    atomic bool sensorUpdateReady <- false;
    elapsedMillis halfSecondMillis;
    elapsedMillis oneSecondMillis;
    

    // Timer interval in microseconds
    const u32 SENSOR_TIMER_INTERVAL_US <- 50000;  // 50ms

    // Timer callback - defined first since it's used by setup
    public void sensorTimerCallback() {
        // This runs in interrupt context - keep it minimal
        // Just set a flag to process in main loop
        sensorUpdateReady <- true;
    }

    // Process sensor updates - defined before loop
    public void processSensorUpdates() {
        // Poll ADS1115 devices (non-blocking, advances state machine)
        ADS1115Manager.update();

        // Poll MAX31856 thermocouple (non-blocking)
        MAX31856Manager.update();

        // Poll BME280 ambient sensor (reads every 1 second)
        BME280Manager.update();

        // Process all sensor readings into SensorValues
        SensorProcessor.processAllInputs();
    }

    // Mark which EValueIds have hardware based on AppConfig
    void populateHardwareFlags() {
        // Temperature inputs
        for (u8 i <- 0; i < TEMP_INPUT_COUNT; i <- i + 1) {
            EValueId val <- global.appConfig.tempInputs[i].assignedValue;
            if (val != global.EValueId.VALUE_UNASSIGNED) {
                SensorValues.setHasHardware(val, true);
            }
        }

        // Pressure inputs
        for (u8 i <- 0; i < PRESSURE_INPUT_COUNT; i <- i + 1) {
            EValueId val <- global.appConfig.pressureInputs[i].assignedValue;
            if (val != global.EValueId.VALUE_UNASSIGNED) {
                SensorValues.setHasHardware(val, true);
            }
        }

        // EGT (thermocouple)
        if (global.appConfig.egtEnabled) {
            SensorValues.setHasHardware(global.EValueId.TURBO1_TURB_INLET_TEMP, true);
        }

        // BME280 (ambient sensors)
        if (global.appConfig.bme280Enabled) {
            SensorValues.setHasHardware(global.EValueId.AMBIENT_PRES, true);
            SensorValues.setHasHardware(global.EValueId.AMBIENT_TEMP, true);
            SensorValues.setHasHardware(global.EValueId.AMBIENT_HUMIDITY, true);
        }
    }

    // Send J1939 messages - defined before loop
    public void sendJ1939Messages() {
        // Every 500ms - send fast-updating data
        if (halfSecondMillis >= 500) {
            J1939Bus.sendPgnGeneric(65270);  // Inlet/Exhaust Conditions 1
            J1939Bus.sendPgnGeneric(65263);  // Engine Fluid Level/Pressure 1
            J1939Bus.sendPgnGeneric(65190);  // Turbocharger Information 5

            halfSecondMillis <- 0;
        }

        // Every 1000ms - send slower-updating data
        if (oneSecondMillis >= 1000) {
            J1939Bus.sendPgnGeneric(65269);  // Ambient Conditions
            J1939Bus.sendPgnGeneric(65262);  // Engine Temperature 1
            J1939Bus.sendPgnGeneric(65129);  // Engine Temperature 2
            J1939Bus.sendPgnGeneric(65189);  // Turbocharger Information 4
            J1939Bus.sendPgnGeneric(65164);  // Engine Temperature 3

            oneSecondMillis <- 0;
        }
    }

    public void setup() {
        SensorValues.initialize();
        Serial.begin(115200);
        // Wait for USB serial connection (up to 3 seconds)
        u32 startTime <- millis();
        u32 elapsed <- millis() - startTime;
        while (!Serial && elapsed < 3000) {
            elapsed <- millis() - startTime;
        }

        Serial.println("OSSM Initializing...");

        // Load configuration from EEPROM (or use defaults)
        bool configLoaded <- ConfigStorage.loadConfig(global.appConfig);
        if (!configLoaded) {
            Serial.println("Loading default configuration");
            ConfigStorage.loadDefaults(global.appConfig);
            // Save defaults to EEPROM for next boot
            ConfigStorage.saveConfig(global.appConfig);
        } else {
            Serial.println("Configuration loaded from EEPROM");
        }

        // Populate hardware flags from loaded config
        populateHardwareFlags();

        // Initialize managers with configuration
        ADS1115Manager.initialize(global.appConfig);
        MAX31856Manager.initialize(global.appConfig);
        BME280Manager.initialize(global.appConfig);
        SensorProcessor.initialize();

        // Initialize J1939 bus
        J1939Bus.initialize();

        // Initialize serial command handler
        SerialCommandHandler.initialize();

        // Start sensor polling timer (50ms interval)
        sensorTimer.begin(sensorTimerCallback, SENSOR_TIMER_INTERVAL_US);

        Serial.println("OSSM Ready");
    }

    public void loop() {
        // Process sensor updates when timer fires
        if (sensorUpdateReady) {
            processSensorUpdates();
            sensorUpdateReady <- false;
        }

        // Process serial commands
        SerialCommandHandler.update();

        // Send J1939 messages on their own timing
        sendJ1939Messages();
    }
}
