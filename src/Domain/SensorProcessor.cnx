// Sensor processing logic
// Reads from hardware managers and stores values in SensorValues

#include <Arduino.h>
#include <AppConfig.cnx>
#include <Data/ADS1115Manager.cnx>
#include <Data/MAX31856Manager.cnx>
#include <Data/BME280Manager.cnx>
#include <Display/SensorConvert.cnx>
#include <Display/HardwareMap.cnx>
#include <Data/SensorValues.cnx>

scope SensorProcessor {
    IntervalTimer sensorTimer;
    atomic bool sensorUpdateReady <- false;
    const u32 SENSOR_TIMER_INTERVAL_US <- 50000;  // 50ms

    void sensorTimerISR() {
        sensorUpdateReady <- true;
    }

    // Get atmospheric pressure for PSIG conversion (from BME280 or default)
    f32 getAtmosphericPressurekPa() {
        f32 baro <- SensorValues.current[EValueId.AMBIENT_PRES].value;
        if (baro > 0.0) {
            return baro;
        }
        return SensorConvert.defaultAtmosphericPressure();
    }

    // Process temperature inputs
    void processTempInputs() {
        for (u8 i <- 0; i < TEMP_INPUT_COUNT; i +<- 1) {
            EValueId val <- appConfig.tempInputs[i].assignedValue;
            if (val = EValueId.VALUE_UNASSIGNED) {
                continue;
            }

            u8 device <- HardwareMap.tempDevice(i);
            u8 channel <- HardwareMap.tempChannel(i);
            f32 voltage <- ADS1115Manager.getVoltage(device, channel);
            f32 tempC <- SensorConvert.ntcTemperature(voltage, appConfig.tempInputs[i]);

            SensorValues.current[val].value <- tempC;
        }
    }

    // Process pressure inputs
    void processPressureInputs() {
        for (u8 i <- 0; i < PRESSURE_INPUT_COUNT; i +<- 1) {
            EValueId val <- appConfig.pressureInputs[i].assignedValue;
            if (val = EValueId.VALUE_UNASSIGNED) {
                continue;
            }

            u8 device <- HardwareMap.pressureDevice(i);
            u8 channel <- HardwareMap.pressureChannel(i);
            f32 voltage <- ADS1115Manager.getVoltage(device, channel);
            f32 atm <- getAtmosphericPressurekPa();
            f32 pressurekPa <- SensorConvert.pressure(voltage, appConfig.pressureInputs[i], atm);

            SensorValues.current[val].value <- pressurekPa;
        }
    }

    // Process EGT from MAX31856
    void processEgt() {
        bool egtReady <- MAX31856Manager.isEnabled();
        if (appConfig.egtEnabled && egtReady) {
            f32 temp <- MAX31856Manager.getTemperatureC();
            SensorValues.current[EValueId.TURBO1_TURB_INLET_TEMP].value <- temp;
        }
    }

    // Process BME280 ambient sensors
    void processBme280() {
        bool bmeReady <- BME280Manager.isEnabled();
        if (appConfig.bme280Enabled && bmeReady) {
            f32 temp <- BME280Manager.getTemperatureC();
            f32 humidity <- BME280Manager.getHumidity();
            f32 pressure <- BME280Manager.getPressurekPa();
            SensorValues.current[EValueId.AMBIENT_TEMP].value <- temp;
            SensorValues.current[EValueId.AMBIENT_HUMIDITY].value <- humidity;
            SensorValues.current[EValueId.AMBIENT_PRES].value <- pressure;
        }
    }

    // Process all enabled inputs
    void processAllInputs() {
        processTempInputs();
        processPressureInputs();
        processEgt();
        processBme280();
    }

    // Poll all hardware managers and process readings
    void pollAndProcess() {
        ADS1115Manager.update();
        MAX31856Manager.update();
        BME280Manager.update();
        processAllInputs();
    }

    public void initialize() {
        sensorTimer.begin(sensorTimerISR, SENSOR_TIMER_INTERVAL_US);
    }

    // Called from main loop - checks ISR flag and processes if ready
    public void update() {
        if (sensorUpdateReady) {
            pollAndProcess();
            sensorUpdateReady <- false;
        }
    }
}
