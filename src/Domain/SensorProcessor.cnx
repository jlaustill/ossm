// Sensor processing logic
// Reads from hardware managers and stores values in SensorValues

#include <Arduino.h>
#include <AppConfig.cnx>
#include <Data/ADS1115Manager.cnx>
#include <Data/MAX31856Manager.cnx>
#include <Data/BME280Manager.cnx>
#include <Display/SensorConvert.cnx>
#include <Display/HardwareMap.cnx>
#include <Data/SensorValues.cnx>

scope SensorProcessor {
    IntervalTimer sensorTimer;
    atomic bool sensorUpdateReady <- false;
    const u32 SENSOR_TIMER_INTERVAL_US <- 50000;  // 50ms

    void sensorTimerCallback() {
        sensorUpdateReady <- true;
    }

    // Get atmospheric pressure for PSIG conversion (from BME280 or default)
    f32 getAtmosphericPressurekPa() {
        f32 baro <- global.SensorValues.current[global.EValueId.AMBIENT_PRES].value;
        if (baro > 0.0) {
            return baro;
        }
        return global.SensorConvert.defaultAtmosphericPressure();
    }

    // Process temperature inputs
    void processTempInputs() {
        for (u8 i <- 0; i < TEMP_INPUT_COUNT; i +<- 1) {
            EValueId val <- global.appConfig.tempInputs[i].assignedValue;
            if (val = global.EValueId.VALUE_UNASSIGNED) {
                continue;
            }

            u8 device <- global.HardwareMap.tempDevice(i);
            u8 channel <- global.HardwareMap.tempChannel(i);
            f32 voltage <- global.ADS1115Manager.getVoltage(device, channel);
            f32 tempC <- global.SensorConvert.ntcTemperature(voltage, global.appConfig.tempInputs[i]);

            global.SensorValues.current[val].value <- tempC;
        }
    }

    // Process pressure inputs
    void processPressureInputs() {
        for (u8 i <- 0; i < PRESSURE_INPUT_COUNT; i +<- 1) {
            EValueId val <- global.appConfig.pressureInputs[i].assignedValue;
            if (val = global.EValueId.VALUE_UNASSIGNED) {
                continue;
            }

            u8 device <- global.HardwareMap.pressureDevice(i);
            u8 channel <- global.HardwareMap.pressureChannel(i);
            f32 voltage <- global.ADS1115Manager.getVoltage(device, channel);
            f32 atm <- this.getAtmosphericPressurekPa();
            f32 pressurekPa <- global.SensorConvert.pressure(voltage, global.appConfig.pressureInputs[i], atm);

            global.SensorValues.current[val].value <- pressurekPa;
        }
    }

    // Process EGT from MAX31856
    void processEgt() {
        bool egtReady <- global.MAX31856Manager.isEnabled();
        if (global.appConfig.egtEnabled && egtReady) {
            f32 temp <- global.MAX31856Manager.getTemperatureC();
            global.SensorValues.current[global.EValueId.TURBO1_TURB_INLET_TEMP].value <- temp;
        }
    }

    // Process BME280 ambient sensors
    void processBme280() {
        bool bmeReady <- global.BME280Manager.isEnabled();
        if (global.appConfig.bme280Enabled && bmeReady) {
            f32 temp <- global.BME280Manager.getTemperatureC();
            f32 humidity <- global.BME280Manager.getHumidity();
            f32 pressure <- global.BME280Manager.getPressurekPa();
            global.SensorValues.current[global.EValueId.AMBIENT_TEMP].value <- temp;
            global.SensorValues.current[global.EValueId.AMBIENT_HUMIDITY].value <- humidity;
            global.SensorValues.current[global.EValueId.AMBIENT_PRES].value <- pressure;
        }
    }

    // Process all enabled inputs
    void processAllInputs() {
        this.processTempInputs();
        this.processPressureInputs();
        this.processEgt();
        this.processBme280();
    }

    // Poll all hardware managers and process readings
    void pollAndProcess() {
        ADS1115Manager.update();
        MAX31856Manager.update();
        BME280Manager.update();
        this.processAllInputs();
    }

    public void initialize() {
        sensorTimer.begin(sensorTimerCallback, SENSOR_TIMER_INTERVAL_US);
    }

    // Called from main loop - checks ISR flag and processes if ready
    public void update() {
        if (sensorUpdateReady) {
            this.pollAndProcess();
            sensorUpdateReady <- false;
        }
    }
}
