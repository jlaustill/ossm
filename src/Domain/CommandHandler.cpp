/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "CommandHandler.h"

// CommandHandler.cnx - Unified command processing for OSSM
// Both serial and CAN pass u8[8] here. Zero SPN knowledge.
// Uses appConfig directly - no config passing.
#include <AppConfig.h>
#include <Data/ConfigStorage.h>
#include <Domain/Hardware.h>
#include <Display/Presets.h>
#include <Display/InputValid.h>

#include <stdint.h>
#include <stdbool.h>

/* Scope: CommandHandler */

EValueCategory CommandHandler_getValueCategory(EValueId valueId) {
    switch (valueId) {
        case EValueId_AMBIENT_PRES: {
            return EValueCategory_VALUE_CAT_BME280;
            break;
        }
        case EValueId_AMBIENT_TEMP: {
            return EValueCategory_VALUE_CAT_BME280;
            break;
        }
        case EValueId_AMBIENT_HUMIDITY: {
            return EValueCategory_VALUE_CAT_BME280;
            break;
        }
        case EValueId_TURBO1_TURB_INLET_TEMP: {
            return EValueCategory_VALUE_CAT_EGT;
            break;
        }
        case EValueId_TURBO1_COMP_INLET_PRES: {
            return EValueCategory_VALUE_CAT_PRESSURE;
            break;
        }
        case EValueId_TURBO1_COMP_OUTLET_PRES: {
            return EValueCategory_VALUE_CAT_PRESSURE;
            break;
        }
        case EValueId_CAC1_INLET_PRES: {
            return EValueCategory_VALUE_CAT_PRESSURE;
            break;
        }
        case EValueId_CAC1_OUTLET_PRES: {
            return EValueCategory_VALUE_CAT_PRESSURE;
            break;
        }
        case EValueId_MANIFOLD1_ABS_PRES: {
            return EValueCategory_VALUE_CAT_PRESSURE;
            break;
        }
        case EValueId_OIL_PRES: {
            return EValueCategory_VALUE_CAT_PRESSURE;
            break;
        }
        case EValueId_COOLANT_PRES: {
            return EValueCategory_VALUE_CAT_PRESSURE;
            break;
        }
        case EValueId_FUEL_PRES: {
            return EValueCategory_VALUE_CAT_PRESSURE;
            break;
        }
        case EValueId_TURBO1_COMP_INLET_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        case EValueId_TURBO1_COMP_OUTLET_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        case EValueId_CAC1_INLET_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        case EValueId_CAC1_OUTLET_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        case EValueId_MANIFOLD1_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        case EValueId_OIL_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        case EValueId_COOLANT_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        case EValueId_FUEL_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        case EValueId_ENGINE_BAY_TEMP: {
            return EValueCategory_VALUE_CAT_TEMPERATURE;
            break;
        }
        default: {
            return EValueCategory_VALUE_CAT_UNKNOWN;
            break;
        }
    }
}

static ECommandResult CommandHandler_enableValue(const uint8_t data[8]) {
    EValueId valueId = static_cast<EValueId>(data[1]);
    EValueCategory category = CommandHandler_getValueCategory(valueId);
    if (category == EValueCategory_VALUE_CAT_UNKNOWN) {
        return ECommandResult_CMD_UNKNOWN_VALUE;
    }
    switch (category) {
        case EValueCategory_VALUE_CAT_TEMPERATURE: {
            bool validInput = InputValid_isValidTempInput(data[2]);
            if (!validInput) {
                return ECommandResult_CMD_INVALID_SENSOR_NUMBER;
            }
            for (uint8_t i = 0; i < TEMP_INPUT_COUNT; i += 1) {
                if (appConfig.tempInputs[i].assignedValue == valueId) {
                    appConfig.tempInputs[i].assignedValue = EValueId_VALUE_UNASSIGNED;
                }
            }
            appConfig.tempInputs[data[2] - 1].assignedValue = valueId;
            break;
        }
        case EValueCategory_VALUE_CAT_PRESSURE: {
            bool validInput = InputValid_isValidPressureInput(data[2]);
            if (!validInput) {
                return ECommandResult_CMD_INVALID_SENSOR_NUMBER;
            }
            for (uint8_t i = 0; i < PRESSURE_INPUT_COUNT; i += 1) {
                if (appConfig.pressureInputs[i].assignedValue == valueId) {
                    appConfig.pressureInputs[i].assignedValue = EValueId_VALUE_UNASSIGNED;
                }
            }
            appConfig.pressureInputs[data[2] - 1].assignedValue = valueId;
            break;
        }
        case EValueCategory_VALUE_CAT_EGT: {
            appConfig.egtEnabled = true;
            break;
        }
        case EValueCategory_VALUE_CAT_BME280: {
            appConfig.bme280Enabled = true;
            break;
        }
        default: {
            return ECommandResult_CMD_UNKNOWN_VALUE;
            break;
        }
    }
    Hardware_initialize(appConfig);
    return ECommandResult_CMD_SUCCESS;
}

static ECommandResult CommandHandler_disableValue(const uint8_t data[8]) {
    EValueId valueId = static_cast<EValueId>(data[1]);
    EValueCategory category = CommandHandler_getValueCategory(valueId);
    if (category == EValueCategory_VALUE_CAT_UNKNOWN) {
        return ECommandResult_CMD_UNKNOWN_VALUE;
    }
    switch (category) {
        case EValueCategory_VALUE_CAT_TEMPERATURE: {
            for (uint8_t i = 0; i < TEMP_INPUT_COUNT; i += 1) {
                if (appConfig.tempInputs[i].assignedValue == valueId) {
                    appConfig.tempInputs[i].assignedValue = EValueId_VALUE_UNASSIGNED;
                }
            }
            break;
        }
        case EValueCategory_VALUE_CAT_PRESSURE: {
            for (uint8_t i = 0; i < PRESSURE_INPUT_COUNT; i += 1) {
                if (appConfig.pressureInputs[i].assignedValue == valueId) {
                    appConfig.pressureInputs[i].assignedValue = EValueId_VALUE_UNASSIGNED;
                }
            }
            break;
        }
        case EValueCategory_VALUE_CAT_EGT: {
            appConfig.egtEnabled = false;
            break;
        }
        case EValueCategory_VALUE_CAT_BME280: {
            appConfig.bme280Enabled = false;
            break;
        }
        default: {
            return ECommandResult_CMD_UNKNOWN_VALUE;
            break;
        }
    }
    Hardware_initialize(appConfig);
    return ECommandResult_CMD_SUCCESS;
}

static ECommandResult CommandHandler_setPressureRange(const uint8_t data[8]) {
    bool valid = InputValid_isValidPressureInput(data[1]);
    if (!valid) {
        return ECommandResult_CMD_INVALID_SENSOR_NUMBER;
    }
    uint16_t maxPressure = (static_cast<uint16_t>(data[2]) << 8) | static_cast<uint16_t>(data[3]);
    appConfig.pressureInputs[data[1] - 1].maxPressure = maxPressure;
    return ECommandResult_CMD_SUCCESS;
}

static ECommandResult CommandHandler_setTcType(const uint8_t data[8]) {
    bool valid = Presets_isValidTcType(data[1]);
    if (!valid) {
        return ECommandResult_CMD_INVALID_TC_TYPE;
    }
    appConfig.thermocoupleType = static_cast<EThermocoupleType>(data[1]);
    return ECommandResult_CMD_SUCCESS;
}

static ECommandResult CommandHandler_applyNtcPreset(const uint8_t data[8]) {
    bool validInput = InputValid_isValidTempInput(data[1]);
    if (!validInput) {
        return ECommandResult_CMD_INVALID_SENSOR_NUMBER;
    }
    bool validPreset = Presets_isValidNtcPreset(data[2]);
    if (!validPreset) {
        return ECommandResult_CMD_INVALID_PRESET;
    }
    uint8_t idx = data[1] - 1;
    appConfig.tempInputs[idx].coeffA = Presets_ntcCoeffA(data[2]);
    appConfig.tempInputs[idx].coeffB = Presets_ntcCoeffB(data[2]);
    appConfig.tempInputs[idx].coeffC = Presets_ntcCoeffC(data[2]);
    appConfig.tempInputs[idx].resistorValue = Presets_ntcResistor(data[2]);
    return ECommandResult_CMD_SUCCESS;
}

static ECommandResult CommandHandler_applyPressurePreset(const uint8_t data[8]) {
    bool validInput = InputValid_isValidPressureInput(data[1]);
    if (!validInput) {
        return ECommandResult_CMD_INVALID_SENSOR_NUMBER;
    }
    bool validPreset = Presets_isValidPressurePreset(data[2]);
    if (!validPreset) {
        return ECommandResult_CMD_INVALID_PRESET;
    }
    uint8_t idx = data[1] - 1;
    bool isBar = Presets_isBarPreset(data[2]);
    if (isBar) {
        appConfig.pressureInputs[idx].maxPressure = Presets_barPresetValue(data[2]);
        appConfig.pressureInputs[idx].pressureType = EPressureType_PRESSURE_TYPE_PSIA;
    } else {
        appConfig.pressureInputs[idx].maxPressure = Presets_psiPresetValue(data[2]);
        appConfig.pressureInputs[idx].pressureType = EPressureType_PRESSURE_TYPE_PSIG;
    }
    return ECommandResult_CMD_SUCCESS;
}

static ECommandResult CommandHandler_save(void) {
    bool saved = ConfigStorage_saveConfig(appConfig);
    if (saved) {
        return ECommandResult_CMD_SUCCESS;
    }
    return ECommandResult_CMD_SAVE_FAILED;
}

static ECommandResult CommandHandler_reset(void) {
    ConfigStorage_loadDefaults(appConfig);
    return ECommandResult_CMD_SUCCESS;
}

ECommandResult CommandHandler_setNtcParam(uint8_t input, uint8_t param, float value) {
    bool validInput = InputValid_isValidTempInput(input);
    if (!validInput) {
        return ECommandResult_CMD_INVALID_SENSOR_NUMBER;
    }
    uint8_t idx = input - 1;
    switch (param) {
        case 0: {
            appConfig.tempInputs[idx].coeffA = value;
            break;
        }
        case 1: {
            appConfig.tempInputs[idx].coeffB = value;
            break;
        }
        case 2: {
            appConfig.tempInputs[idx].coeffC = value;
            break;
        }
        case 3: {
            appConfig.tempInputs[idx].resistorValue = value;
            break;
        }
        default: {
            return ECommandResult_CMD_INVALID_NTC_PARAM;
            break;
        }
    }
    return ECommandResult_CMD_SUCCESS;
}

ECommandResult CommandHandler_process(const uint8_t data[8]) {
    switch (data[0]) {
        case 1: {
            return CommandHandler_enableValue(data);
            break;
        }
        case 2: {
            return CommandHandler_disableValue(data);
            break;
        }
        case 3: {
            return CommandHandler_setPressureRange(data);
            break;
        }
        case 4: {
            return CommandHandler_setTcType(data);
            break;
        }
        case 6: {
            return CommandHandler_save();
            break;
        }
        case 7: {
            return CommandHandler_reset();
            break;
        }
        case 8: {
            return CommandHandler_applyNtcPreset(data);
            break;
        }
        case 9: {
            return CommandHandler_applyPressurePreset(data);
            break;
        }
        default: {
            return ECommandResult_CMD_UNKNOWN_COMMAND;
            break;
        }
    }
}
