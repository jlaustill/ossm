/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "SerialCommandHandler.h"

/**
 * Serial Command Handler
 * Thin transport: parse serial text -> u8[8] -> CommandHandler.process()
 */
#include <Arduino.h>
#include <EEPROM.h>
#include <Parse.hpp>
#include <AppConfig.h>
#include <Domain/CommandHandler.h>
#include <Display/FaultDecode.h>
#include <Data/ADS1115Manager.h>
#include <Data/MAX31856Manager.h>
#include <Data/SensorValues.h>
#include <Display/ValueName.h>

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

// Module state for command buffer
char cmdBuffer[129] = "";

uint8_t cmdIndex = 0;

SeaDash::Parse::ParseResult parsed = (SeaDash::Parse::ParseResult){ .data = {0}, .count = 0, .success = false };

/* Scope: SerialCommandHandler */

static void SerialCommandHandler_printResult(ECommandResult result) {
    switch (result) {
        case ECommandResult_CMD_SUCCESS: {
            Serial.println("OK");
            break;
        }
        case ECommandResult_CMD_UNKNOWN_COMMAND: {
            Serial.println("ERR,Unknown command");
            break;
        }
        case ECommandResult_CMD_UNKNOWN_VALUE: {
            Serial.println("ERR,Unknown value");
            break;
        }
        case ECommandResult_CMD_MISSING_VALUE: {
            Serial.println("ERR,Missing value");
            break;
        }
        case ECommandResult_CMD_MISSING_SENSOR_NUMBER: {
            Serial.println("ERR,Missing sensor number");
            break;
        }
        case ECommandResult_CMD_INVALID_SENSOR_NUMBER: {
            Serial.println("ERR,Invalid sensor number");
            break;
        }
        case ECommandResult_CMD_INVALID_TC_TYPE: {
            Serial.println("ERR,Invalid TC type (0-7)");
            break;
        }
        case ECommandResult_CMD_INVALID_PRESET: {
            Serial.println("ERR,Invalid preset");
            break;
        }
        case ECommandResult_CMD_INVALID_NTC_PARAM: {
            Serial.println("ERR,Invalid NTC param (0-3)");
            break;
        }
        case ECommandResult_CMD_SAVE_FAILED: {
            Serial.println("ERR,Save failed");
            break;
        }
        default: {
            Serial.println("ERR,Unknown error");
            break;
        }
    }
}

static void SerialCommandHandler_printEnabledValues(void) {
    Serial.println("=== Enabled Values ===");
    for (uint8_t i = 0; i < TEMP_INPUT_COUNT; i = i + 1) {
        EValueId val = appConfig.tempInputs[i].assignedValue;
        if (val != EValueId_VALUE_UNASSIGNED) {
            Serial.print("temp");
            Serial.print(i + 1);
            Serial.print(": ");
            ValueName_print(val);
            Serial.println();
        }
    }
    for (uint8_t i = 0; i < PRESSURE_INPUT_COUNT; i = i + 1) {
        EValueId val = appConfig.pressureInputs[i].assignedValue;
        if (val != EValueId_VALUE_UNASSIGNED) {
            Serial.print("pres");
            Serial.print(i + 1);
            Serial.print(": ");
            ValueName_print(val);
            Serial.println();
        }
    }
    if (appConfig.egtEnabled) {
        Serial.println("EGT: enabled");
    }
    if (appConfig.bme280Enabled) {
        Serial.println("BME280: enabled");
    }
}

static void SerialCommandHandler_handleQuery(void) {
    uint8_t queryType = 0;
    if (parsed.count > 1) {
        queryType = parsed.data[1];
    }
    switch (queryType) {
        case 0: {
            SerialCommandHandler_printEnabledValues();
            break;
        }
        case 4: {
            Serial.println("=== Full Configuration ===");
            Serial.print("J1939 Address: ");
            Serial.println(appConfig.j1939SourceAddress);
            Serial.print("EGT Enabled: ");
            if (appConfig.egtEnabled) {
                Serial.println("Yes");
            } else {
                Serial.println("No");
            }
            Serial.print("TC Type: ");
            Serial.println(appConfig.thermocoupleType);
            Serial.print("BME280 Enabled: ");
            if (appConfig.bme280Enabled) {
                Serial.println("Yes");
            } else {
                Serial.println("No");
            }
            SerialCommandHandler_printEnabledValues();
            break;
        }
        default: {
            Serial.println("ERR,Query type 0 or 4");
            break;
        }
    }
}

static void SerialCommandHandler_handleReadSensors(void) {
    uint8_t sensorType = 0;
    if (parsed.count > 1) {
        sensorType = parsed.data[1];
    }
    switch (sensorType) {
        case 0: {
            Serial.println("=== Live Sensor Values ===");
            if (appConfig.egtEnabled) {
                Serial.print("EGT: ");
                uint8_t faultStatus = MAX31856Manager_getFaultStatus();
                if (faultStatus == 0) {
                    Serial.print(SensorValues_current[EValueId_TURBO1_TURB_INLET_TEMP].value, 1);
                    Serial.println(" C");
                } else {
                    Serial.println("FAULT");
                }
            }
            for (uint8_t i = 0; i < TEMP_INPUT_COUNT; i = i + 1) {
                EValueId val = appConfig.tempInputs[i].assignedValue;
                if (val != EValueId_VALUE_UNASSIGNED) {
                    Serial.print("temp");
                    Serial.print(i + 1);
                    Serial.print(": ");
                    Serial.print(SensorValues_current[val].value, 1);
                    Serial.println(" C");
                }
            }
            for (uint8_t i = 0; i < PRESSURE_INPUT_COUNT; i = i + 1) {
                EValueId val = appConfig.pressureInputs[i].assignedValue;
                if (val != EValueId_VALUE_UNASSIGNED) {
                    Serial.print("pres");
                    Serial.print(i + 1);
                    Serial.print(": ");
                    Serial.print(SensorValues_current[val].value, 2);
                    Serial.println(" kPa");
                }
            }
            if (appConfig.bme280Enabled) {
                Serial.print("Ambient Temp: ");
                Serial.print(SensorValues_current[EValueId_AMBIENT_TEMP].value, 1);
                Serial.println(" C");
                Serial.print("Humidity: ");
                Serial.print(SensorValues_current[EValueId_AMBIENT_HUMIDITY].value, 1);
                Serial.println(" %");
                Serial.print("Baro: ");
                Serial.print(SensorValues_current[EValueId_AMBIENT_PRES].value, 2);
                Serial.println(" kPa");
            }
            break;
        }
        case 1: {
            if (!appConfig.egtEnabled) {
                Serial.println("ERR,EGT not enabled");
                return;
            }
            Serial.print("EGT: ");
            uint8_t faultStatus = MAX31856Manager_getFaultStatus();
            if (faultStatus == 0) {
                Serial.print(SensorValues_current[EValueId_TURBO1_TURB_INLET_TEMP].value, 1);
                Serial.println(" C");
            } else {
                Serial.print("FAULT (0x");
                Serial.print(faultStatus, HEX);
                Serial.println(")");
            }
            break;
        }
        case 2: {
            Serial.println("=== Temperature Sensors ===");
            for (uint8_t i = 0; i < TEMP_INPUT_COUNT; i = i + 1) {
                EValueId val = appConfig.tempInputs[i].assignedValue;
                if (val != EValueId_VALUE_UNASSIGNED) {
                    Serial.print("temp");
                    Serial.print(i + 1);
                    Serial.print(": ");
                    Serial.print(SensorValues_current[val].value, 1);
                    Serial.println(" C");
                }
            }
            break;
        }
        case 3: {
            Serial.println("=== Pressure Sensors ===");
            for (uint8_t i = 0; i < PRESSURE_INPUT_COUNT; i = i + 1) {
                EValueId val = appConfig.pressureInputs[i].assignedValue;
                if (val != EValueId_VALUE_UNASSIGNED) {
                    Serial.print("pres");
                    Serial.print(i + 1);
                    Serial.print(": ");
                    Serial.print(SensorValues_current[val].value, 2);
                    Serial.println(" kPa");
                }
            }
            break;
        }
        case 4: {
            if (!appConfig.bme280Enabled) {
                Serial.println("ERR,BME280 not enabled");
                return;
            }
            Serial.println("=== BME280 Ambient ===");
            Serial.print("Ambient Temp: ");
            Serial.print(SensorValues_current[EValueId_AMBIENT_TEMP].value, 1);
            Serial.println(" C");
            Serial.print("Humidity: ");
            Serial.print(SensorValues_current[EValueId_AMBIENT_HUMIDITY].value, 1);
            Serial.println(" %");
            Serial.print("Baro: ");
            Serial.print(SensorValues_current[EValueId_AMBIENT_PRES].value, 2);
            Serial.println(" kPa");
            break;
        }
        default: {
            Serial.println("ERR,Sensor type 0-4");
            break;
        }
    }
}

static void SerialCommandHandler_reportFaults(void) {
    uint8_t egtFault = MAX31856Manager_getFaultStatus();
    bool hasFault = FaultDecode_hasFault(egtFault);
    if (hasFault) {
        Serial.println("--- FAULTS ---");
        Serial.print("EGT: 0x");
        Serial.print(egtFault, HEX);
        Serial.print(" (");
        bool isOpen = FaultDecode_isOpen(egtFault);
        if (isOpen) {
            Serial.print("OPEN ");
        }
        bool isOvuv = FaultDecode_isOvuv(egtFault);
        if (isOvuv) {
            Serial.print("OVUV ");
        }
        bool isTcLow = FaultDecode_isTcLow(egtFault);
        if (isTcLow) {
            Serial.print("TC_LOW ");
        }
        bool isTcHigh = FaultDecode_isTcHigh(egtFault);
        if (isTcHigh) {
            Serial.print("TC_HIGH ");
        }
        bool isCjLow = FaultDecode_isCjLow(egtFault);
        if (isCjLow) {
            Serial.print("CJ_LOW ");
        }
        bool isCjHigh = FaultDecode_isCjHigh(egtFault);
        if (isCjHigh) {
            Serial.print("CJ_HIGH ");
        }
        bool isTcRange = FaultDecode_isTcRange(egtFault);
        if (isTcRange) {
            Serial.print("TC_RANGE ");
        }
        bool isCjRange = FaultDecode_isCjRange(egtFault);
        if (isCjRange) {
            Serial.print("CJ_RANGE ");
        }
        Serial.println(")");
        bool isCritical = FaultDecode_isCritical(egtFault);
        if (isCritical) {
            Serial.println("WARNING: Critical fault - check sensor connection");
        }
    }
}

static void SerialCommandHandler_handleDumpEeprom(void) {
    uint32_t configSize = sizeof(AppConfig);
    Serial.println("=== EEPROM Dump ===");
    Serial.print("SIZE:");
    Serial.println(configSize);
    Serial.println("HEX:");
    for (uint32_t i = 0; i < configSize; i = i + 1) {
        uint8_t byte = EEPROM.read(i);
        if (byte < 0x10) {
            Serial.print("0");
        }
        Serial.print(byte, HEX);
        uint32_t pos = i + 1;
        if (pos % 16 == 0) {
            Serial.println();
        } else {
            Serial.print(" ");
        }
    }
    if (configSize % 16 != 0) {
        Serial.println();
    }
    Serial.println("END");
}

static void SerialCommandHandler_processCommand(void) {
    uint32_t len = strlen(cmdBuffer);
    if (len == 0) {
        return;
    }
    parsed = SeaDash::Parse::parse(cmdBuffer, ',');
    if (!parsed.success || parsed.count < 1) {
        Serial.println("ERR,Parse failed");
        return;
    }
    uint8_t cmdNum = parsed.data[0];
    switch (cmdNum) {
        case 5: {
            SerialCommandHandler_handleQuery();
            SerialCommandHandler_reportFaults();
            return;
            break;
        }
        case 10: {
            SerialCommandHandler_handleReadSensors();
            SerialCommandHandler_reportFaults();
            return;
            break;
        }
        case 11: {
            SerialCommandHandler_handleDumpEeprom();
            return;
            break;
        }
        case 12: {
            ADS1115Manager_printDebugInfo();
            return;
            break;
        }
    }
    uint8_t data[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    for (uint8_t i = 0; i < 8; i += 1) {
        if (i < parsed.count) {
            data[i] = static_cast<uint8_t>(parsed.data[i]);
        }
    }
    ECommandResult result = CommandHandler_process(data);
    SerialCommandHandler_printResult(result);
    SerialCommandHandler_reportFaults();
}

void SerialCommandHandler_initialize(void) {
    cmdIndex = 0;
    strncpy(cmdBuffer, "", 128); cmdBuffer[128] = '\0';
    Serial.println("OSSM Command Interface Ready");
    Serial.println("Commands: 1,valueId[,input] | 2,valueId | 5,query | 6 | 7 | 8,in,preset | 9,in,preset");
}

void SerialCommandHandler_update(void) {
    int32_t available = Serial.available();
    while (available > 0) {
        int32_t readResult = Serial.read();
        char c = ((readResult) & 0xFFU);
        if (c == '\n' || c == '\r') {
            if (cmdIndex > 0) {
                SerialCommandHandler_processCommand();
                cmdIndex = 0;
                strncpy(cmdBuffer, "", 128); cmdBuffer[128] = '\0';
            }
        } else if (cmdIndex < 127) {
            cmdBuffer[cmdIndex] = c;
            cmdIndex = cmdIndex + 1;
        }
        available = Serial.available();
    }
}
