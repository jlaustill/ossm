// Fault Code Decoding
// MAX31856 thermocouple fault bit interpretation
// Provides pure functions for checking individual fault conditions

#include <stdint.h>

scope fault_decode {
    // MAX31856 fault bit masks
    public const u8 FAULT_OPEN <- 0x01;      // Open thermocouple
    public const u8 FAULT_OVUV <- 0x02;      // Over/under voltage
    public const u8 FAULT_TC_LOW <- 0x04;    // TC temp too low
    public const u8 FAULT_TC_HIGH <- 0x08;   // TC temp too high
    public const u8 FAULT_CJ_LOW <- 0x10;    // Cold junction too low
    public const u8 FAULT_CJ_HIGH <- 0x20;   // Cold junction too high
    public const u8 FAULT_TC_RANGE <- 0x40;  // TC out of range
    public const u8 FAULT_CJ_RANGE <- 0x80;  // CJ out of range

    // Fault index constants (for string table lookup)
    public const u8 IDX_OPEN <- 0;
    public const u8 IDX_OVUV <- 1;
    public const u8 IDX_TC_LOW <- 2;
    public const u8 IDX_TC_HIGH <- 3;
    public const u8 IDX_CJ_LOW <- 4;
    public const u8 IDX_CJ_HIGH <- 5;
    public const u8 IDX_TC_RANGE <- 6;
    public const u8 IDX_CJ_RANGE <- 7;

    // Check if any fault is present
    public bool hasFault(u8 faultCode) {
        if (faultCode != 0) { return true; }
        return false;
    }

    // Check individual fault bits
    public bool isOpen(u8 faultCode) {
        u8 masked <- faultCode & this.FAULT_OPEN;
        if (masked != 0) { return true; }
        return false;
    }

    public bool isOvuv(u8 faultCode) {
        u8 masked <- faultCode & this.FAULT_OVUV;
        if (masked != 0) { return true; }
        return false;
    }

    public bool isTcLow(u8 faultCode) {
        u8 masked <- faultCode & this.FAULT_TC_LOW;
        if (masked != 0) { return true; }
        return false;
    }

    public bool isTcHigh(u8 faultCode) {
        u8 masked <- faultCode & this.FAULT_TC_HIGH;
        if (masked != 0) { return true; }
        return false;
    }

    public bool isCjLow(u8 faultCode) {
        u8 masked <- faultCode & this.FAULT_CJ_LOW;
        if (masked != 0) { return true; }
        return false;
    }

    public bool isCjHigh(u8 faultCode) {
        u8 masked <- faultCode & this.FAULT_CJ_HIGH;
        if (masked != 0) { return true; }
        return false;
    }

    public bool isTcRange(u8 faultCode) {
        u8 masked <- faultCode & this.FAULT_TC_RANGE;
        if (masked != 0) { return true; }
        return false;
    }

    public bool isCjRange(u8 faultCode) {
        u8 masked <- faultCode & this.FAULT_CJ_RANGE;
        if (masked != 0) { return true; }
        return false;
    }

    // Get fault index for first set bit (for iterative decoding)
    // Returns 255 if no fault
    public u8 getFirstFaultIndex(u8 faultCode) {
        if (faultCode & this.FAULT_OPEN) { return this.IDX_OPEN; }
        if (faultCode & this.FAULT_OVUV) { return this.IDX_OVUV; }
        if (faultCode & this.FAULT_TC_LOW) { return this.IDX_TC_LOW; }
        if (faultCode & this.FAULT_TC_HIGH) { return this.IDX_TC_HIGH; }
        if (faultCode & this.FAULT_CJ_LOW) { return this.IDX_CJ_LOW; }
        if (faultCode & this.FAULT_CJ_HIGH) { return this.IDX_CJ_HIGH; }
        if (faultCode & this.FAULT_TC_RANGE) { return this.IDX_TC_RANGE; }
        if (faultCode & this.FAULT_CJ_RANGE) { return this.IDX_CJ_RANGE; }
        return 255;
    }

    // Count number of faults
    public u8 countFaults(u8 faultCode) {
        u8 count <- 0;
        if (faultCode & this.FAULT_OPEN) { count <- count + 1; }
        if (faultCode & this.FAULT_OVUV) { count <- count + 1; }
        if (faultCode & this.FAULT_TC_LOW) { count <- count + 1; }
        if (faultCode & this.FAULT_TC_HIGH) { count <- count + 1; }
        if (faultCode & this.FAULT_CJ_LOW) { count <- count + 1; }
        if (faultCode & this.FAULT_CJ_HIGH) { count <- count + 1; }
        if (faultCode & this.FAULT_TC_RANGE) { count <- count + 1; }
        if (faultCode & this.FAULT_CJ_RANGE) { count <- count + 1; }
        return count;
    }

    // Check if fault is critical (open or range errors)
    public bool isCritical(u8 faultCode) {
        u8 criticalMask <- this.FAULT_OPEN | this.FAULT_TC_RANGE | this.FAULT_CJ_RANGE;
        u8 masked <- faultCode & criticalMask;
        if (masked != 0) { return true; }
        return false;
    }
}
