// Byte Utility Functions
// Common byte manipulation operations for embedded systems
// Tests bit shifting, masking, and byte extraction patterns

#include <stdint.h>

scope byte_utils {
    // Build uint16_t from high and low bytes (big-endian)
    public u16 makeU16BE(u8 high, u8 low) {
        u16 h <- high;
        u16 l <- low;
        u16 result <- (h << 8) | l;
        return result;
    }

    // Build uint16_t from low and high bytes (little-endian)
    public u16 makeU16LE(u8 low, u8 high) {
        u16 h <- high;
        u16 l <- low;
        u16 result <- (h << 8) | l;
        return result;
    }

    // Extract high byte from uint16_t
    public u8 highByte(u16 value) {
        u8 result <- (value >> 8) & 0xFF;
        return result;
    }

    // Extract low byte from uint16_t
    public u8 lowByte(u16 value) {
        u8 result <- value & 0xFF;
        return result;
    }

    // Build uint32_t from 4 bytes (big-endian)
    public u32 makeU32BE(u8 b3, u8 b2, u8 b1, u8 b0) {
        u32 byte3 <- b3;
        u32 byte2 <- b2;
        u32 byte1 <- b1;
        u32 byte0 <- b0;
        u32 result <- (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
        return result;
    }

    // Build uint32_t from 4 bytes (little-endian)
    public u32 makeU32LE(u8 b0, u8 b1, u8 b2, u8 b3) {
        u32 byte3 <- b3;
        u32 byte2 <- b2;
        u32 byte1 <- b1;
        u32 byte0 <- b0;
        u32 result <- (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
        return result;
    }

    // Extract byte 0 (lowest) from uint32_t
    public u8 byte0(u32 value) {
        u8 result <- value & 0xFF;
        return result;
    }

    // Extract byte 1 from uint32_t
    public u8 byte1(u32 value) {
        u8 result <- (value >> 8) & 0xFF;
        return result;
    }

    // Extract byte 2 from uint32_t
    public u8 byte2(u32 value) {
        u8 result <- (value >> 16) & 0xFF;
        return result;
    }

    // Extract byte 3 (highest) from uint32_t
    public u8 byte3(u32 value) {
        u8 result <- (value >> 24) & 0xFF;
        return result;
    }

    // Check if bit is set in byte
    public bool isBitSet(u8 value, u8 bit) {
        if (bit > 7) { return false; }
        u8 mask <- 1 << bit;
        if ((value & mask) != 0) {
            return true;
        }
        return false;
    }

    // Set bit in byte (returns new value)
    public u8 setBit(u8 value, u8 bit) {
        if (bit > 7) { return value; }
        u8 mask <- 1 << bit;
        u8 result <- value | mask;
        return result;
    }

    // Clear bit in byte (returns new value)
    public u8 clearBit(u8 value, u8 bit) {
        if (bit > 7) { return value; }
        u8 mask <- 1 << bit;
        u8 invMask <- ~mask;
        u8 result <- value & invMask;
        return result;
    }

    // Clamp value to range
    public u8 clampU8(u8 value, u8 minVal, u8 maxVal) {
        if (value < minVal) { return minVal; }
        if (value > maxVal) { return maxVal; }
        return value;
    }

    // Clamp 16-bit value to range
    public u16 clampU16(u16 value, u16 minVal, u16 maxVal) {
        if (value < minVal) { return minVal; }
        if (value > maxVal) { return maxVal; }
        return value;
    }
}
