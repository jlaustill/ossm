// J1939 CAN Bus Communication
// Handles CAN hardware, outbound sensor PGNs, and inbound message buffering

#include <Arduino.h>
#include <AppConfig.cnx>
#include "FlexCAN_T4.h"
#include <J1939Message.h>
#include "J1939Encode.cnx"
#include <Data/J1939Config.cnx>
#include <Data/SensorValues.cnx>

scope J1939Bus {
    // CAN bus instance - OSSM v0.0.2 uses CAN1 (D22/D23)
    FlexCAN_T4<CAN1, RX_SIZE_256, TX_SIZE_16> canBus;

    // Buffered config command from CAN receive interrupt
    atomic bool configCmdPending <- false;
    u8[8] configCmdData <- [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF];

    // ─── Helpers ─────────────────────────────────────────────────────

    u32 buildCanId(u16 pgn, u8 priority, u8 sourceAddr) {
        u32 id <- 0;
        id[26,3] <- priority;
        id[8,18] <- pgn;
        id[0,8] <- sourceAddr;
        return id;
    }

    void fillBuffer(u8[8] buf) {
        for (u8 i <- 0; i < 8; i +<- 1) {
            buf[i] <- 0xFF;
        }
    }

    bool isValueEnabled(EValueId valueId) {
        return global.SensorValues.current[valueId].hasHardware;
    }

    public void sendMessage(u16 pgn, const u8[8] buf) {
        CAN_message_t msg;
        msg.flags.extended <- 1;
        msg.id <- this.buildCanId(pgn, 6, global.appConfig.j1939SourceAddress);
        msg.len <- 8;

        for (u8 i <- 0; i < 8; i +<- 1) {
            msg.buf[i] <- buf[i];
        }

        this.canBus.write(msg);
    }

    // ─── Generic PGN sender ─────────────────────────────────────────

    public void sendPgnGeneric(u16 pgn) {
        u8[8] buf;
        this.fillBuffer(buf);

        for (u8 i <- 0; i < SPN_CONFIG_COUNT; i <- i + 1) {
            TSpnConfig cfg <- SPN_CONFIGS[i];

            if (cfg.pgn != pgn) {
                continue;
            }

            bool hasHw <- this.isValueEnabled(cfg.source);
            if (!hasHw) {
                continue;
            }

            f32 value <- global.SensorValues.current[cfg.source].value;
            u16 encoded <- global.J1939Encode.encode(value, cfg.resolution, cfg.offset);

            u8 pos <- cfg.bytePos - 1;
            buf[pos] <- (u8)(encoded & 0xFF);
            if (cfg.dataLength = 2) {
                buf[pos + 1] <- (u8)((encoded >> 8) & 0xFF);
            }
        }

        this.sendMessage(pgn, buf);
    }

    // ─── Pending config command interface ────────────────────────────

    public bool hasPendingCommand() {
        return configCmdPending;
    }

    public void getPendingCommand(u8[8] outData) {
        critical {
            for (u8 i <- 0; i < 8; i +<- 1) {
                outData[i] <- configCmdData[i];
            }
            configCmdPending <- false;
        }
    }

    // ─── CAN message reception ──────────────────────────────────────

    void sniffDataPrivateISR(const CAN_message_t msg) {
        J1939Message message <- { pgn: 0 };
        message.setCanId(msg.id);
        message.setData(msg.buf);

        // PGN 65280 (0xFF00) - Configuration commands: buffer for main loop
        if (message.pgn = 65280) {
            for (u8 i <- 0; i < 8; i +<- 1) {
                configCmdData[i] <- msg.buf[i];
            }
            configCmdPending <- true;
            return;
        }

        // PGN 59904 - Request: repeat on bus
        if (message.pgn = 59904) {
            this.canBus.write(msg);
        }
    }

    // ─── Initialization ─────────────────────────────────────────────

    public void initialize() {
        Serial.println("J1939 Bus initializing");

        this.canBus.begin();
        this.canBus.setBaudRate(250 * 1000);
        this.canBus.setMaxMB(16);
        this.canBus.enableFIFO();
        this.canBus.enableFIFOInterrupt();
        this.canBus.onReceive(this.sniffDataPrivateISR);
        this.canBus.mailboxStatus();

        Serial.print("J1939 Source Address: ");
        Serial.println(global.appConfig.j1939SourceAddress);
    }
}
