/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "Display/FaultDecode.h"

#include <stdint.h>
#include <stdbool.h>

// Fault Code Decoding
// MAX31856 thermocouple fault bit interpretation
// Provides pure functions for checking individual fault conditions
/* Scope: FaultDecode */
const uint8_t FaultDecode_FAULT_OPEN = 0x01;
const uint8_t FaultDecode_FAULT_OVUV = 0x02;
const uint8_t FaultDecode_FAULT_TC_LOW = 0x04;
const uint8_t FaultDecode_FAULT_TC_HIGH = 0x08;
const uint8_t FaultDecode_FAULT_CJ_LOW = 0x10;
const uint8_t FaultDecode_FAULT_CJ_HIGH = 0x20;
const uint8_t FaultDecode_FAULT_TC_RANGE = 0x40;
const uint8_t FaultDecode_FAULT_CJ_RANGE = 0x80;
const uint8_t FaultDecode_IDX_OPEN = 0;
const uint8_t FaultDecode_IDX_OVUV = 1;
const uint8_t FaultDecode_IDX_TC_LOW = 2;
const uint8_t FaultDecode_IDX_TC_HIGH = 3;
const uint8_t FaultDecode_IDX_CJ_LOW = 4;
const uint8_t FaultDecode_IDX_CJ_HIGH = 5;
const uint8_t FaultDecode_IDX_TC_RANGE = 6;
const uint8_t FaultDecode_IDX_CJ_RANGE = 7;

bool FaultDecode_hasFault(uint8_t faultCode) {
    if (faultCode != 0) {
        return true;
    }
    return false;
}

bool FaultDecode_isOpen(uint8_t faultCode) {
    uint8_t masked = faultCode & FaultDecode_FAULT_OPEN;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool FaultDecode_isOvuv(uint8_t faultCode) {
    uint8_t masked = faultCode & FaultDecode_FAULT_OVUV;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool FaultDecode_isTcLow(uint8_t faultCode) {
    uint8_t masked = faultCode & FaultDecode_FAULT_TC_LOW;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool FaultDecode_isTcHigh(uint8_t faultCode) {
    uint8_t masked = faultCode & FaultDecode_FAULT_TC_HIGH;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool FaultDecode_isCjLow(uint8_t faultCode) {
    uint8_t masked = faultCode & FaultDecode_FAULT_CJ_LOW;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool FaultDecode_isCjHigh(uint8_t faultCode) {
    uint8_t masked = faultCode & FaultDecode_FAULT_CJ_HIGH;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool FaultDecode_isTcRange(uint8_t faultCode) {
    uint8_t masked = faultCode & FaultDecode_FAULT_TC_RANGE;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool FaultDecode_isCjRange(uint8_t faultCode) {
    uint8_t masked = faultCode & FaultDecode_FAULT_CJ_RANGE;
    if (masked != 0) {
        return true;
    }
    return false;
}

uint8_t FaultDecode_getFirstFaultIndex(uint8_t faultCode) {
    if (faultCode & FaultDecode_FAULT_OPEN) {
        return FaultDecode_IDX_OPEN;
    }
    if (faultCode & FaultDecode_FAULT_OVUV) {
        return FaultDecode_IDX_OVUV;
    }
    if (faultCode & FaultDecode_FAULT_TC_LOW) {
        return FaultDecode_IDX_TC_LOW;
    }
    if (faultCode & FaultDecode_FAULT_TC_HIGH) {
        return FaultDecode_IDX_TC_HIGH;
    }
    if (faultCode & FaultDecode_FAULT_CJ_LOW) {
        return FaultDecode_IDX_CJ_LOW;
    }
    if (faultCode & FaultDecode_FAULT_CJ_HIGH) {
        return FaultDecode_IDX_CJ_HIGH;
    }
    if (faultCode & FaultDecode_FAULT_TC_RANGE) {
        return FaultDecode_IDX_TC_RANGE;
    }
    if (faultCode & FaultDecode_FAULT_CJ_RANGE) {
        return FaultDecode_IDX_CJ_RANGE;
    }
    return 255;
}

uint8_t FaultDecode_countFaults(uint8_t faultCode) {
    uint8_t count = 0;
    if (faultCode & FaultDecode_FAULT_OPEN) {
        count = count + 1;
    }
    if (faultCode & FaultDecode_FAULT_OVUV) {
        count = count + 1;
    }
    if (faultCode & FaultDecode_FAULT_TC_LOW) {
        count = count + 1;
    }
    if (faultCode & FaultDecode_FAULT_TC_HIGH) {
        count = count + 1;
    }
    if (faultCode & FaultDecode_FAULT_CJ_LOW) {
        count = count + 1;
    }
    if (faultCode & FaultDecode_FAULT_CJ_HIGH) {
        count = count + 1;
    }
    if (faultCode & FaultDecode_FAULT_TC_RANGE) {
        count = count + 1;
    }
    if (faultCode & FaultDecode_FAULT_CJ_RANGE) {
        count = count + 1;
    }
    return count;
}

bool FaultDecode_isCritical(uint8_t faultCode) {
    uint8_t criticalMask = FaultDecode_FAULT_OPEN | FaultDecode_FAULT_TC_RANGE | FaultDecode_FAULT_CJ_RANGE;
    uint8_t masked = faultCode & criticalMask;
    if (masked != 0) {
        return true;
    }
    return false;
}
