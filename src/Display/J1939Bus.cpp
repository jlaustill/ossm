/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "J1939Bus.h"

// J1939 CAN Bus Communication
// Handles CAN hardware, outbound sensor PGNs, and inbound message buffering
#include <Arduino.h>
#include <AppConfig.h>
#include "FlexCAN_T4.h"
#include <J1939Message.h>
#include "J1939Encode.h"
#include <Data/J1939Config.h>
#include <Data/SensorValues.h>

#include <stdint.h>
#include <stdbool.h>

// ADR-050: Platform-portable IRQ wrappers for critical sections
#if defined(__arm__) || defined(__ARM_ARCH)
// ARM platforms (including ARM Arduino like Teensy 4.x, Due, Zero)
// Provide inline assembly PRIMASK access to avoid CMSIS header dependencies
__attribute__((always_inline)) static inline uint32_t __cnx_get_PRIMASK(void) {
    uint32_t result;
    __asm volatile ("MRS %0, primask" : "=r" (result));
    return result;
}
__attribute__((always_inline)) static inline void __cnx_set_PRIMASK(uint32_t mask) {
    __asm volatile ("MSR primask, %0" :: "r" (mask) : "memory");
}
#if defined(ARDUINO)
static inline void __cnx_disable_irq(void) { noInterrupts(); }
#else
__attribute__((always_inline)) static inline void __cnx_disable_irq(void) {
    __asm volatile ("cpsid i" ::: "memory");
}
#endif
#elif defined(__AVR__)
// AVR Arduino: use SREG for interrupt state
// Note: Uses PRIMASK naming for API consistency across platforms (AVR has no PRIMASK)
// Returns uint8_t which is implicitly widened to uint32_t at call sites - this is intentional
static inline uint8_t __cnx_get_PRIMASK(void) { return SREG; }
static inline void __cnx_set_PRIMASK(uint8_t mask) { SREG = mask; }
static inline void __cnx_disable_irq(void) { cli(); }
#else
// Fallback: assume CMSIS is available
static inline void __cnx_disable_irq(void) { __disable_irq(); }
static inline uint32_t __cnx_get_PRIMASK(void) { return __get_PRIMASK(); }
static inline void __cnx_set_PRIMASK(uint32_t mask) { __set_PRIMASK(mask); }
#endif

/* Scope: J1939Bus */
static FlexCAN_T4<CAN1,RX_SIZE_256,TX_SIZE_16> J1939Bus_canBus = {};
static bool J1939Bus_configCmdPending = false;
static uint8_t J1939Bus_configCmdData[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

static uint32_t J1939Bus_buildCanId(uint16_t pgn, uint8_t priority, uint8_t sourceAddr) {
    uint32_t id = 0;
    id = (id & ~(((1U << 3) - 1) << 26)) | ((priority & ((1U << 3) - 1)) << 26);
    id = (id & ~(((1U << 18) - 1) << 8)) | ((pgn & ((1U << 18) - 1)) << 8);
    id = (id & ~(0xFFU << 0)) | ((sourceAddr & 0xFFU) << 0);
    return id;
}

static void J1939Bus_fillBuffer(uint8_t buf[8]) {
    for (uint8_t i = 0; i < 8; i += 1) {
        buf[i] = 0xFF;
    }
}

static bool J1939Bus_isValueEnabled(EValueId valueId) {
    return SensorValues_current[valueId].hasHardware;
}

void J1939Bus_sendMessage(uint16_t pgn, const uint8_t buf[8]) {
    CAN_message_t msg = {};
    msg.flags.extended = 1;
    msg.id = J1939Bus_buildCanId(pgn, 6, appConfig.j1939SourceAddress);
    msg.len = 8;
    for (uint8_t i = 0; i < 8; i += 1) {
        msg.buf[i] = buf[i];
    }
    J1939Bus_canBus.write(msg);
}

void J1939Bus_sendPgnGeneric(uint16_t pgn) {
    uint8_t buf[8] = {0};
    J1939Bus_fillBuffer(buf);
    for (uint8_t i = 0; i < SPN_CONFIG_COUNT; i = i + 1) {
        TSpnConfig cfg = SPN_CONFIGS[i];
        if (cfg.pgn != pgn) {
            continue;
        }
        bool hasHw = J1939Bus_isValueEnabled(cfg.source);
        if (!hasHw) {
            continue;
        }
        float value = SensorValues_current[cfg.source].value;
        uint16_t encoded = J1939Encode_encode(value, cfg.resolution, cfg.offset);
        uint8_t pos = cfg.bytePos - 1;
        buf[pos] = static_cast<uint8_t>((encoded & 0xFF));
        if (cfg.dataLength == 2) {
            buf[pos + 1] = static_cast<uint8_t>(((encoded >> 8) & 0xFF));
        }
    }
    J1939Bus_sendMessage(pgn, buf);
}

bool J1939Bus_hasPendingCommand(void) {
    return J1939Bus_configCmdPending;
}

void J1939Bus_getPendingCommand(uint8_t outData[8]) {
    {
        uint32_t __primask = __cnx_get_PRIMASK();
        __cnx_disable_irq();
        for (uint8_t i = 0; i < 8; i += 1) {
            outData[i] = J1939Bus_configCmdData[i];
        }
        J1939Bus_configCmdPending = false;
        __cnx_set_PRIMASK(__primask);
    }
}

static void J1939Bus_sniffDataPrivateISR(const CAN_message_t& msg) {
    J1939Message message = {};
    message.pgn = 0;
    message.setCanId(msg.id);
    message.setData(msg.buf);
    if (message.pgn == 65280) {
        for (uint8_t i = 0; i < 8; i += 1) {
            J1939Bus_configCmdData[i] = msg.buf[i];
        }
        J1939Bus_configCmdPending = true;
        return;
    }
    if (message.pgn == 59904) {
        J1939Bus_canBus.write(msg);
    }
}

void J1939Bus_initialize(void) {
    Serial.println("J1939 Bus initializing");
    J1939Bus_canBus.begin();
    J1939Bus_canBus.setBaudRate(250000);
    J1939Bus_canBus.setMaxMB(16);
    J1939Bus_canBus.enableFIFO();
    J1939Bus_canBus.enableFIFOInterrupt();
    J1939Bus_canBus.onReceive(J1939Bus_sniffDataPrivateISR);
    J1939Bus_canBus.mailboxStatus();
    Serial.print("J1939 Source Address: ");
    Serial.println(appConfig.j1939SourceAddress);
}
