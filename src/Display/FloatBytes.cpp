/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "FloatBytes.h"

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

static_assert(sizeof(float) == 4, "Float bit indexing requires 32-bit float");
static_assert(sizeof(double) == 8, "Float bit indexing requires 64-bit double");

// Float Byte Utilities
// IEEE 754 float reconstruction from byte arrays
// Used in J1939 command parsing for float parameter values
/* Scope: FloatBytes */

float FloatBytes_fromBytesLE(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) {
    float result = 0.0;
    uint32_t __bits_result; memcpy(&__bits_result, &result, sizeof(result)); __bits_result = (__bits_result & ~(0xFFU << 0)) | (((uint32_t)b0 & 0xFFU) << 0); memcpy(&result, &__bits_result, sizeof(result));
    __bits_result = (__bits_result & ~(0xFFU << 8)) | (((uint32_t)b1 & 0xFFU) << 8); memcpy(&result, &__bits_result, sizeof(result));
    __bits_result = (__bits_result & ~(0xFFU << 16)) | (((uint32_t)b2 & 0xFFU) << 16); memcpy(&result, &__bits_result, sizeof(result));
    __bits_result = (__bits_result & ~(0xFFU << 24)) | (((uint32_t)b3 & 0xFFU) << 24); memcpy(&result, &__bits_result, sizeof(result));
    return result;
}

float FloatBytes_fromBytesBE(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) {
    float result = 0.0;
    uint32_t __bits_result; memcpy(&__bits_result, &result, sizeof(result)); __bits_result = (__bits_result & ~(0xFFU << 0)) | (((uint32_t)b3 & 0xFFU) << 0); memcpy(&result, &__bits_result, sizeof(result));
    __bits_result = (__bits_result & ~(0xFFU << 8)) | (((uint32_t)b2 & 0xFFU) << 8); memcpy(&result, &__bits_result, sizeof(result));
    __bits_result = (__bits_result & ~(0xFFU << 16)) | (((uint32_t)b1 & 0xFFU) << 16); memcpy(&result, &__bits_result, sizeof(result));
    __bits_result = (__bits_result & ~(0xFFU << 24)) | (((uint32_t)b0 & 0xFFU) << 24); memcpy(&result, &__bits_result, sizeof(result));
    return result;
}

uint8_t FloatBytes_getByte0(float value) {
    uint32_t __bits_value;
    return (memcpy(&__bits_value, &value, sizeof(value)), (__bits_value & 0xFFU));
}

uint8_t FloatBytes_getByte1(float value) {
    uint32_t __bits_value;
    return (memcpy(&__bits_value, &value, sizeof(value)), ((__bits_value >> 8) & 0xFFU));
}

uint8_t FloatBytes_getByte2(float value) {
    uint32_t __bits_value;
    return (memcpy(&__bits_value, &value, sizeof(value)), ((__bits_value >> 16) & 0xFFU));
}

uint8_t FloatBytes_getByte3(float value) {
    uint32_t __bits_value;
    return (memcpy(&__bits_value, &value, sizeof(value)), ((__bits_value >> 24) & 0xFFU));
}

bool FloatBytes_isValidFloat(float value) {
    if (value != value) {
        return false;
    }
    if (value > 3.4e38) {
        return false;
    }
    if (value < -3.4e38) {
        return false;
    }
    return true;
}
