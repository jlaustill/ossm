/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "fault_decode.h"

// Fault Code Decoding
// MAX31856 thermocouple fault bit interpretation
// Provides pure functions for checking individual fault conditions
#include <stdint.h>

#include <stdint.h>
#include <stdbool.h>

/* Scope: fault_decode */
const uint8_t fault_decode_FAULT_OPEN = 0x01;
const uint8_t fault_decode_FAULT_OVUV = 0x02;
const uint8_t fault_decode_FAULT_TC_LOW = 0x04;
const uint8_t fault_decode_FAULT_TC_HIGH = 0x08;
const uint8_t fault_decode_FAULT_CJ_LOW = 0x10;
const uint8_t fault_decode_FAULT_CJ_HIGH = 0x20;
const uint8_t fault_decode_FAULT_TC_RANGE = 0x40;
const uint8_t fault_decode_FAULT_CJ_RANGE = 0x80;
const uint8_t fault_decode_IDX_OPEN = 0;
const uint8_t fault_decode_IDX_OVUV = 1;
const uint8_t fault_decode_IDX_TC_LOW = 2;
const uint8_t fault_decode_IDX_TC_HIGH = 3;
const uint8_t fault_decode_IDX_CJ_LOW = 4;
const uint8_t fault_decode_IDX_CJ_HIGH = 5;
const uint8_t fault_decode_IDX_TC_RANGE = 6;
const uint8_t fault_decode_IDX_CJ_RANGE = 7;

bool fault_decode_hasFault(uint8_t faultCode) {
    if (faultCode != 0) {
        return true;
    }
    return false;
}

bool fault_decode_isOpen(uint8_t faultCode) {
    uint8_t masked = faultCode & fault_decode_FAULT_OPEN;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool fault_decode_isOvuv(uint8_t faultCode) {
    uint8_t masked = faultCode & fault_decode_FAULT_OVUV;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool fault_decode_isTcLow(uint8_t faultCode) {
    uint8_t masked = faultCode & fault_decode_FAULT_TC_LOW;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool fault_decode_isTcHigh(uint8_t faultCode) {
    uint8_t masked = faultCode & fault_decode_FAULT_TC_HIGH;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool fault_decode_isCjLow(uint8_t faultCode) {
    uint8_t masked = faultCode & fault_decode_FAULT_CJ_LOW;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool fault_decode_isCjHigh(uint8_t faultCode) {
    uint8_t masked = faultCode & fault_decode_FAULT_CJ_HIGH;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool fault_decode_isTcRange(uint8_t faultCode) {
    uint8_t masked = faultCode & fault_decode_FAULT_TC_RANGE;
    if (masked != 0) {
        return true;
    }
    return false;
}

bool fault_decode_isCjRange(uint8_t faultCode) {
    uint8_t masked = faultCode & fault_decode_FAULT_CJ_RANGE;
    if (masked != 0) {
        return true;
    }
    return false;
}

uint8_t fault_decode_getFirstFaultIndex(uint8_t faultCode) {
    if (faultCode & fault_decode_FAULT_OPEN) {
        return fault_decode_IDX_OPEN;
    }
    if (faultCode & fault_decode_FAULT_OVUV) {
        return fault_decode_IDX_OVUV;
    }
    if (faultCode & fault_decode_FAULT_TC_LOW) {
        return fault_decode_IDX_TC_LOW;
    }
    if (faultCode & fault_decode_FAULT_TC_HIGH) {
        return fault_decode_IDX_TC_HIGH;
    }
    if (faultCode & fault_decode_FAULT_CJ_LOW) {
        return fault_decode_IDX_CJ_LOW;
    }
    if (faultCode & fault_decode_FAULT_CJ_HIGH) {
        return fault_decode_IDX_CJ_HIGH;
    }
    if (faultCode & fault_decode_FAULT_TC_RANGE) {
        return fault_decode_IDX_TC_RANGE;
    }
    if (faultCode & fault_decode_FAULT_CJ_RANGE) {
        return fault_decode_IDX_CJ_RANGE;
    }
    return 255;
}

uint8_t fault_decode_countFaults(uint8_t faultCode) {
    uint8_t count = 0;
    if (faultCode & fault_decode_FAULT_OPEN) {
        count = count + 1;
    }
    if (faultCode & fault_decode_FAULT_OVUV) {
        count = count + 1;
    }
    if (faultCode & fault_decode_FAULT_TC_LOW) {
        count = count + 1;
    }
    if (faultCode & fault_decode_FAULT_TC_HIGH) {
        count = count + 1;
    }
    if (faultCode & fault_decode_FAULT_CJ_LOW) {
        count = count + 1;
    }
    if (faultCode & fault_decode_FAULT_CJ_HIGH) {
        count = count + 1;
    }
    if (faultCode & fault_decode_FAULT_TC_RANGE) {
        count = count + 1;
    }
    if (faultCode & fault_decode_FAULT_CJ_RANGE) {
        count = count + 1;
    }
    return count;
}

bool fault_decode_isCritical(uint8_t faultCode) {
    uint8_t criticalMask = fault_decode_FAULT_OPEN | fault_decode_FAULT_TC_RANGE | fault_decode_FAULT_CJ_RANGE;
    uint8_t masked = faultCode & criticalMask;
    if (masked != 0) {
        return true;
    }
    return false;
}
