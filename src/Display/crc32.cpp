/**
 * Generated by C-Next Transpiler
 * A safer C for embedded systems
 */

#include "crc32.h"

// crc32.cnx - Memory-safe CRC32 checksum calculation
// Requires C-Next v0.1.12+ for full C++ mode support
#include "AppConfig.h"

#include <stdint.h>
#include <string.h>

/* Scope: crc32 */

static uint32_t crc32_crcByte(uint32_t crc, uint8_t byte) {
    uint32_t c = crc ^ byte;
    for (int32_t j = 0; j < 8; j += 1) {
        if (c & 1) {
            c = (c >> 1) ^ 0xEDB88320;
        } else {
            c = c >> 1;
        }
    }
    return c;
}

static uint32_t crc32_crcFloat(uint32_t* crc, float value) {
    char buf[5] = "";
    memcpy(&buf[0], &value, 4);
    (*crc) = crc32_crcByte((*crc), buf[0]);
    (*crc) = crc32_crcByte((*crc), buf[1]);
    (*crc) = crc32_crcByte((*crc), buf[2]);
    (*crc) = crc32_crcByte((*crc), buf[3]);
    return (*crc);
}

uint32_t crc32_calculateChecksum(const AppConfig* config) {
    uint32_t crc = 0xFFFFFFFF;
    crc = crc32_crcByte(crc, config->magic & 0xFF);
    crc = crc32_crcByte(crc, (config->magic >> 8) & 0xFF);
    crc = crc32_crcByte(crc, (config->magic >> 16) & 0xFF);
    crc = crc32_crcByte(crc, (config->magic >> 24) & 0xFF);
    crc = crc32_crcByte(crc, config->version);
    crc = crc32_crcByte(crc, config->j1939SourceAddress);
    for (uint32_t i = 0; i < TEMP_INPUT_COUNT; i += 1) {
        crc = crc32_crcByte(crc, config->tempInputs[i].assignedSpn & 0xFF);
        crc = crc32_crcByte(crc, (config->tempInputs[i].assignedSpn >> 8) & 0xFF);
        crc = crc32_crcFloat(&crc, config->tempInputs[i].coeffA);
        crc = crc32_crcFloat(&crc, config->tempInputs[i].coeffB);
        crc = crc32_crcFloat(&crc, config->tempInputs[i].coeffC);
        crc = crc32_crcFloat(&crc, config->tempInputs[i].resistorValue);
    }
    for (uint32_t i = 0; i < PRESSURE_INPUT_COUNT; i += 1) {
        crc = crc32_crcByte(crc, config->pressureInputs[i].assignedSpn & 0xFF);
        crc = crc32_crcByte(crc, (config->pressureInputs[i].assignedSpn >> 8) & 0xFF);
        crc = crc32_crcByte(crc, config->pressureInputs[i].maxPressure & 0xFF);
        crc = crc32_crcByte(crc, (config->pressureInputs[i].maxPressure >> 8) & 0xFF);
        crc = crc32_crcByte(crc, config->pressureInputs[i].pressureType);
    }
    crc = crc32_crcByte(crc, config->egtEnabled);
    crc = crc32_crcByte(crc, config->thermocoupleType);
    crc = crc32_crcByte(crc, config->bme280Enabled);
    return ~crc;
}
